{"version":3,"file":"jsy-self-bootstrap.cjs","sources":["../code/jsy_lambda_operators.jsy","../code/jsy_foldTop_operators.jsy","../code/jsy_operators.jsy","../code/preprocess_jsy.jsy","../code/optional_comma.jsy","../code/jsy_regexp.jsy","../code/scanner/inject_dedent.jsy","../code/scanner/_location.jsy","../code/scanner/basic_offside.jsy","../code/scanner/context_scanner.jsy","../code/scanner/basic_contexts.jsy","../code/scanner/basic_offside_contexts.jsy","../code/scanner/scan_clike.jsy","../code/scanner/scan_javascript.jsy","../code/scanner/scan_jsx_javascript.jsy","../code/scan_jsy.jsy","../code/transpile_jsy.jsy"],"sourcesContent":["\n\nconst lambda_block_tbl = @{}\n  '': a => @: pre: `((${a}) => {`, post: '})'\n  '>': a => @: pre: `(async (${a}) => {`, post: '})'\n  '>*': a => @: pre: `((async function * (${a}) {`, post: '}).bind(this))'\n  '*>': a => @: pre: `((async function * (${a}) {`, post: '}).bind(this))'\n  '*': a => @: pre: `((function * (${a}) {`, post: '}).bind(this))'\n\nconst lambda_arrow_tbl = @{}\n  __proto__: lambda_block_tbl\n  '': a => @: pre: `((${a}) =>`, post: ')', implicitCommas: true\n  '>': a => @: pre: `(async (${a}) =>`, post: ')', implicitCommas: true\n\n\nconst iife_expr_tbl = @{}\n  '': a => @: pre: `(((${a}) => {`, post: '})())'\n  '>': a => @: pre: `((async (${a}) => {`, post: '})())'\n  '>*': a => @: pre: `((async function * (${a}) {`, post: '}).call(this))'\n  '*>': a => @: pre: `((async function * (${a}) {`, post: '}).call(this))'\n  '*': a => @: pre: `((function * (${a}) {`, post: '}).call(this))'\n\nconst iife_arrow_tbl = @{}\n  __proto__: iife_expr_tbl\n  '': a => @: pre: `(((${a}) =>`, post: ')())', implicitCommas: true\n  '>': a => @: pre: `((async (${a}) =>`, post: ')())', implicitCommas: true\n\n\nconst bindOpResolve = (table, withArgs) =>\n  function opResolve(p) ::\n    const [_, m1, m2] = p.content.match(this.jsy_op)\n    const args = withArgs ? m1 || '' : ''\n    const suffix = (withArgs ? m2 : m1) || ''\n\n    const entry = table[suffix]\n    if undefined === entry ::\n      throw new SyntaxError @ `JSY lambda expression unrecognized specifier (\"${suffix}\")`\n\n    return entry(args)\n\n\n\nexport const at_lambda_offside = @[]\n  @{} jsy_op0: '@=>', jsy_op: /@=>(>?\\*?)/,\n      pre: '(()=>', post: ')',\n      opResolve: bindOpResolve @ lambda_arrow_tbl\n\n  @{} jsy_op0: '@\\\\=>', jsy_op: /@\\\\(.*?)=>(>?\\*?)/,\n      pre: '(()=>', post: ')', implicitCommas: true,\n      opResolve: bindOpResolve @ lambda_arrow_tbl, true\n\n  @{} jsy_op0: '@::', jsy_op: /@::(>?\\*?)/,\n      pre: '(()=>{', post: '})',\n      opResolve: bindOpResolve @ lambda_block_tbl\n\n  @{} jsy_op0: '@\\\\::', jsy_op: /@\\\\(.*?)::(>?\\*?)/,\n      pre: '(()=>{', post: '})',\n      opResolve: bindOpResolve @ lambda_block_tbl, true\n\n\nexport const at_lambda_iife_offside = @[]\n  @{} jsy_op: '::!', pre: ';(()=>{', post: '})();'\n  @{} jsy_op: '::!>', pre: ';(async ()=>{', post: '})();'\n\n  @{} jsy_op0: '@!\\\\::', jsy_op: /@!\\\\(.*?)::(>?\\*?)/,\n      pre: '((()=>', post: ')())',\n      opResolve: bindOpResolve @ iife_expr_tbl, true\n\n  @{} jsy_op0: '@!\\\\=>', jsy_op: /@!\\\\(.*?)=>(>?\\*?)/,\n      pre: '((()=>', post: ')())',\n      opResolve: bindOpResolve @ iife_arrow_tbl, true\n\n  @{} jsy_op0: '@!=>', jsy_op: /@!=>(>?\\*?)/,\n      pre: '((()=>', post: ')())',\n      opResolve: bindOpResolve @ iife_arrow_tbl\n\n  @{} jsy_op0: '@!', jsy_op: /@!(>?\\*?)(?!=>)/,\n      pre: '((()=>{', post: '})())',\n      opResolve: bindOpResolve @ iife_expr_tbl\n\n\nexport default [].concat @\n  at_lambda_offside\n  at_lambda_iife_offside\n\n\n","// Allow use of ';' prefix to JSY operators to foldTop and perform operation\n\nexport const at_foldTop = @[]\n  @{} jsy_op: ';::', pre: ' {', post: '}', foldTop: true\n\n  @{} jsy_op0: ';', jsy_op: @ /;([-+*\\/%^<>&|!?=,.:]+)/\n    pre: ' ', post: null, foldTop: true\n    opResolve: p => @: pre: ' '+p.op_args[0], post: null, foldTop: true\n\nexport function at_prefixFoldTop(at_op) ::\n  let {jsy_op0, jsy_op} = at_op\n  if ! /^[@?]/.test @ jsy_op0 || jsy_op ::\n    return\n\n  if undefined === jsy_op0 ::\n    jsy_op = ';' + jsy_op\n    return @{} ...at_op,\n      jsy_op, foldTop: true\n\n\n  if 'function' !== typeof jsy_op.exec ::\n    throw new Error @ 'Unexpected jsy_op type'\n\n  jsy_op0 = ';' + jsy_op0\n  jsy_op = new RegExp @ `;${jsy_op.source}`, jsy_op.flags\n\n  if 'function' === typeof at_op.opResolve ::\n    return @{} ...at_op,\n      jsy_op0, jsy_op, foldTop: true\n      opResolve: p => @: ... at_op.opResolve(p), foldTop: true\n\n\nexport function apply_prefixFoldTop(... args) ::\n  const res = []\n  for const at_op_list of args ::\n    for const at_op of at_op_list ::\n      const ea = at_prefixFoldTop @ at_op\n      if undefined !== ea ::\n        res.push @ ea\n  return res\n\n","import at_lambda_offside from './jsy_lambda_operators.jsy'\nimport { at_foldTop, apply_prefixFoldTop } from './jsy_foldTop_operators.jsy'\n\n// Order matters here -- list more specific matchers higher (first) in the order\nexport const at_outer_offside = @[]\n  @{} jsy_op: '::()', pre: '(', post: ')', nestBreak: true\n  @{} jsy_op: '::{}', pre: '{', post: '}', nestBreak: true\n  @{} jsy_op: '::[]', pre: '[', post: ']', nestBreak: true\n  @{} jsy_op: '::', pre: ' {', post: '}', nestBreak: true, is_kw_close: true\n\nexport const at_inner_offside_basic = @[]\n  @{} jsy_op: '@:', pre: '({', post: '})', implicitCommas: true, isFoldable: true\n  @{} jsy_op: '@#', pre: '([', post: '])', implicitCommas: true, isFoldable: true\n  @{} jsy_op: '@()', pre: '(', post: ')', implicitCommas: true, isFoldable: true\n  @{} jsy_op: '@{}', pre: '{', post: '}', implicitCommas: true, isFoldable: true\n  @{} jsy_op: '@[]', pre: '[', post: ']', implicitCommas: true, isFoldable: true\n  @{} jsy_op: '@', pre: '(', post: ')', implicitCommas: true, isFoldable: true\n\n\n\nexport const at_experimental_optional_chaining = @[]\n  @{} jsy_op: '?@:', pre: '?.({', post: '})', implicitCommas: true, isFoldable: true\n  @{} jsy_op: '?@#', pre: '?.([', post: '])', implicitCommas: true, isFoldable: true\n  @{} jsy_op: '?@()', pre: '?.(', post: ')', implicitCommas: true, isFoldable: true\n  @{} jsy_op: '?@[]', pre: '?.[', post: ']', implicitCommas: true, isFoldable: true\n  @{} jsy_op: '?@', pre: '?.(', post: ')', implicitCommas: true, isFoldable: true\n\n\n\nconst deprecated_suffix_offside_fold = @{}\n  warn({op}) :: warn_deprecated @ 'suffix offside fold experiment in v0.6.0.  ', {op}\n\nexport const at_experimental_inner_offside_folded = @[]\n  /* experimental ideas; may be removed at any time */\n  @{} ... deprecated_suffix_offside_fold, jsy_op: '@@:', pre: '({', post: '})', implicitCommas: true, isFoldable: true, foldTop: true\n  @{} ... deprecated_suffix_offside_fold, jsy_op: '@@#', pre: '([', post: '])', implicitCommas: true, isFoldable: true, foldTop: true\n  @{} ... deprecated_suffix_offside_fold, jsy_op: '@@', pre: '(', post: ')', implicitCommas: true, isFoldable: true, foldTop: true\n  @{} ... deprecated_suffix_offside_fold, jsy_op: '@;', pre: ' ', post: null, foldTop: true\n  @{} ... deprecated_suffix_offside_fold, jsy_op: '@,', pre: ', ', post: null, foldTop: true\n  @{} ... deprecated_suffix_offside_fold, jsy_op: '@;', pre: ' ', post: null, foldTop: true\n\n\nconst deprecated_functional_composition_experiment = @{}\n  warn({op}) :: warn_deprecated @ 'functional composition experiment in v0.6.0.  ', {op}\n\nexport const at_experimental = @[]\n  /* experimental ideas; may be removed at any time */\n  @{} ... deprecated_functional_composition_experiment, jsy_op: '@|>', pre: '([', post: '].reduce((v,f)=>f(v)))', implicitCommas: true\n  @{} ... deprecated_functional_composition_experiment, jsy_op: '@|>>', pre: '([', post: '].reduce(async (v,f)=>f(v)))', implicitCommas: true\n\n\nexport const at_unknown_ops = @[]\n  @{} jsy_op0: '?@', jsy_op: /\\?@[^\\w\\s]+/,\n  @{} jsy_op0: '::', jsy_op: /::[^\\w\\s]+/,\n  @{} jsy_op0: '@', jsy_op: /@[^\\w\\s]+/,\n\n\nexport const at_inner_offside = [].concat @\n  at_inner_offside_basic\n  apply_prefixFoldTop @ at_inner_offside_basic\n\n  at_lambda_offside\n  apply_prefixFoldTop @ at_lambda_offside\n\n  at_foldTop\n\n  at_experimental_optional_chaining\n  apply_prefixFoldTop @ at_experimental_optional_chaining\n\n  at_experimental_inner_offside_folded\n\n\n\nexport const at_offside = [].concat @\n  at_outer_offside\n  at_inner_offside\n  at_experimental\n\nexport const at_offside_map = at_offside.reduce @\n  (m, ea) => ::\n    if ea.jsy_op0 ::\n      m[ea.jsy_op0] = ea\n\n    if 'string' === typeof ea.jsy_op ::\n      m[ea.jsy_op] = ea\n    return m\n  {}\n\n\nfunction kwExpandOp(p) ::\n  return @{} __proto__: this, pre: p.kw + this.pre\n\nexport const extra_jsy_ops = @{}\n  kw_normal: @{} jsy_op: 'kw', pre: ' (', post: ')', kwExpandOp, in_nested_block: true\n  kw_explicit: @{} jsy_op: 'kw', pre: '', post: '', kwExpandOp, in_nested_block: true\n  tmpl_param: @{} jsy_op: 'tmpl_param', pre: '', post: '', in_nested_block: true\n  jsx_param: @{} jsy_op: 'jsx_param', pre: '', post: '', in_nested_block: true\n\nexport const keywords_with_args = @[] 'if', 'while', 'for await', 'for', 'switch'\nexport const keywords_zero_args = @[] 'catch'\n\nexport const keywords_locator_parts = [].concat @\n  keywords_with_args.map @ e => `else ${e}`\n  keywords_with_args\n  keywords_zero_args\n\n\n\nconst dep_warn_style = @ 'undefined' === typeof HTMLElement\n  ? @[] '%s', '\\x1b[33m', '\\x1b[0m'\n  : @[] '%c', 'color: red', ''\n\nfunction warn_deprecated(msg, ...args) ::\n  const [c, s, e] = dep_warn_style\n  console.warn(`${c}DEPRECATED: ${msg}${c}`, s, ...args, e)\n\n","const rx_all_space = /^[ \\t]*$/ ;\n\nfunction noop() :: return\nconst xform_proto = @{}\n  __proto__: null\n\n  update(arg) ::\n    if 'function' === typeof arg ::\n      this.process = arg\n    else if 'boolean' === typeof arg ::\n      if arg :: return this.dedent()\n      this.process = noop\n    else if 'object' === typeof arg ::\n      Object.assign(this, arg)\n      const process = this.process\n      if 'function' !== typeof process  && 'object' !== typeof process ::\n        return this.update(process)\n    else ::\n      throw new TypeError @ `Unsupported update type: ${typeof arg}`\n\n    return this\n\n  dedent() ::\n    const len_trim = this.ln.len_indent - this.ln.len_inner\n    return this.update @ src_parts => ::\n      const indent = src_parts[0]\n      if rx_all_space.test(indent) ::\n        src_parts[0] = indent.slice(0, len_trim)\n      return src_parts\n\n\nexport function createTransform(ln, xform_cur) ::\n  const xform_obj = Object.create @ xform_proto, @{}\n    next: @{} value: xform_cur\n    depth: @{} value: ln.len_inner\n    ln: @{} value: ln\n\n  xform_obj.process = noop\n  return xform_obj\n\n\nexport function applyPreprocessor(feedback) ::\n  const {preprocess, preprocessor, defines} = feedback || {}\n  if preprocess :: return preprocess\n  if preprocessor :: return feedback.preprocessor()\n  if defines :: return basicPreprocessor(defines)\n\n\nexport function basicPreprocessor(answerFor) ::\n  if 'object' === typeof answerFor ::\n    answerFor = bindAnswerFor(answerFor)\n  else if 'function' !== typeof answerFor ::\n    throw new TypeError @ `Expected a function or object for basicPreprocessor`\n\n\n  const directives = @{}\n    IF(p, arg, state) ::\n      if ! arg :: throw syntaxError(p)\n      return state.handled = !! answerFor(arg)\n\n    ELIF(p, arg, state) ::\n      if ! arg || 'boolean' !== typeof state.handled ::\n        throw syntaxError(p)\n      if state.handled :: return false\n      return state.handled = !! answerFor(arg)\n\n    ELSE(p, arg, state) ::\n      if arg || 'boolean' !== typeof state.handled ::\n        throw syntaxError(p)\n      if state.handled :: return false\n      state.handled = null\n      return true\n\n  const rx = /^#\\s*([A-Z]+\\b)(.*)$/\n\n  const stack = []\n  let allow = true, state = {}\n  return (p, add_xform) => ::\n    const m = rx.exec(p.content)\n    const dispatch = m && directives[m[1]]\n    if ! dispatch :: throw syntaxError(p)\n\n    if ! allow ::\n      state = null\n      return false\n\n    const ans = dispatch @ p, m[2].trim(), state\n    allow = !! ans\n\n    stack.push(state); state = {}\n\n    add_xform @: done, process: allow\n\n  function done(ln) ::\n    state = stack.pop()\n    allow = true\n\n  function syntaxError(p) ::\n    return p.loc.start.syntaxError @ `Preprocessor Invalid: \"${p.content}\"`\n\n\nfunction not_stkop(args) ::\n  const a=args.pop()\n  return !a\nfunction and_stkop(args) ::\n  const a=args.pop(), b=args.pop()\n  return a && b\nfunction or_stkop(args) ::\n  const a=args.pop(), b=args.pop()\n  return a || b\nexport const preprocessor_stack_ops = @{}\n  'false': false, 'true': true, 'FALSE': false, 'TRUE': true\n  '!': Object.assign @ not_stkop, {order: 0}\n  '&&': Object.assign @ and_stkop, {order: 10}\n  '||': Object.assign @ or_stkop, {order: 20}\n  'NOT': and_stkop\n  'AND': and_stkop\n  'OR': or_stkop\n\nexport function bindAnswerFor(defines, preproc_ops=preprocessor_stack_ops) ::\n  return function answerFor(expr_src) ::\n    const pp_expr = expr_src.split(/\\s+/)\n      .map @ key => defines[key] || preproc_ops[key]\n\n    return eval_shuntingYard(pp_expr, expr_src)\n\nexport function eval_shuntingYard(expr, expr_src) ::\n  // see https://en.wikipedia.org/wiki/Shunting-yard_algorithm\n  const args=[], ops=[]\n\n  for const ea of expr ::\n    if 'function' === typeof ea ::\n      // eval all lesser order operations\n      while 0!==ops.length && (0 | ops[0].order) <= (0 | ea.order) ::\n        args.push @ ops.shift() @ args\n\n      // push this operator on the stack\n      ops.unshift(ea)\n\n    else ::\n      args.push(ea)\n\n  // evaluate all operations\n  while 0 !== ops.length ::\n    args.push @ ops.shift() @ args\n\n  if 1 !== args.length ::\n    throw new SyntaxError @\n      `Invalid preprocessor expression: \"${expr_src}\"`\n\n  return args[0]\n\n","const rx_punct = /[,.;:?]/\nconst rx_binary_ops = /\\&\\&|\\|\\|/\n\nconst rx_disrupt_comma_tail = @!\n  const opts = @[] rx_punct, /=>/, /[+-]/, rx_binary_ops\n  return new RegExp @ join_rx(opts) + '\\\\s*$'\n\nconst rx_disrupt_comma_head = @!\n  const opts = @[] rx_punct, rx_binary_ops\n  return new RegExp @ '^\\\\s*' + join_rx(opts)\n\nconst rx_rescue_comma_head = @!\n  const opts = @[] /\\.\\.\\./\n  return new RegExp @ '^\\\\s*' + join_rx(opts)\n\nconst rx_last_bits = /[()\\[\\]{}]|<\\/?\\w*>/ ;\n\nexport default checkOptionalComma\nexport function checkOptionalComma(op, pre_body, post_body) ::\n  const pre_end = pre_body.split(rx_last_bits).pop()\n  if rx_disrupt_comma_tail.test(pre_end) ::\n    return false\n\n  const post_start = post_body.split(rx_last_bits).shift()\n  if rx_disrupt_comma_head.test(post_start) ::\n    if ! rx_rescue_comma_head.test(post_start) ::\n      return false\n\n  if checkSyntax @ `${op.pre} ${pre_body} , post_body ${op.post}` ::\n    return true\n\n  if checkSyntax @ `${op.pre} pre_body , ${post_body} ${op.post}` ::\n    return true\n\n  return false\n\n\nconst checkSyntax = @!\n  const fn_flavors =\n    @[] 'function', 'function*', 'async function', 'async function*'\n    .map @ flavor => ::\n      try :: return Function(`return (${flavor}(){}).constructor`)()\n      catch err :: return null\n    .filter @ e => e\n\n  return function checkSyntax(expr) ::\n    for const FuncKind of fn_flavors ::\n      try ::\n        new FuncKind @ `return ${expr}`\n        return true\n      catch err ::\n\n    return false\n\n\nfunction join_rx(rx_options, capture) ::\n  const opts = Array.from(rx_options)\n    .map @ rx => rx && rx.source\n    .filter(Boolean).join('|')\n\n  return (capture ? '(' : '(?:') + opts + ')'\n\n","import {at_offside, at_unknown_ops, keywords_locator_parts} from './jsy_operators.jsy'\n\nconst regexp_keyword = sz => ::\n  sz = sz.replace(/[ ]+/g, '[ ]+') // allow one or more spaces\n  return `(?:${sz})` // using a non-matching group\n\nconst re_keyword_space_prefix = /^(?:[ \\t]*)/.source ; // start of line and indent\nconst re_keyword_trailer = /(?:[ \\t]*(?=\\W|$))/.source ;\n\nexport const rx_keyword_ops = new RegExp @\n  re_keyword_space_prefix\n    + `(?:${keywords_locator_parts.map(regexp_keyword).join('|')})`\n    + re_keyword_trailer\n  , 'g' // global regexp for lastIndex support\n\n\nconst rx_escape_offside_ops = /[?|+*@:.\\/\\\\\\(\\)\\{\\}\\[\\]\\=\\>]/g ;\nconst re_space_prefix = /(?:^|[ \\t]+)/.source ; // spaces or start of line\nconst re_space_suffix = /(?=$|[ \\t]+)/.source ; // spaces or end of line\n\nconst regexp_from_offside_op = offside_op => ::\n  let op = offside_op.jsy_op\n  if 'string' === typeof op ::\n    // escape Offside operator chars to RegExp\n    op = op.replace @ rx_escape_offside_ops, '\\\\$&'\n    // surrounded by newlines or spacees\n    op = re_space_prefix + op + re_space_suffix\n    return `(?:${op})` // using a non-matching group\n\n  else if op instanceof RegExp ::\n    return op.source\n\nexport const rx_offside_ops = new RegExp @\n  at_offside\n    .map(regexp_from_offside_op)\n    .filter(Boolean)\n    .join('|')\n  'g' // global regexp\n\nexport const rx_unknown_ops = new RegExp @\n  at_unknown_ops\n    .map(regexp_from_offside_op)\n    .filter(Boolean)\n    .join('|')\n  'g' // global regexp\n\n","\nexport default inject_dedent\nexport function inject_dedent(offside_lines, trailing_types) ::\n  if 'function' !== typeof trailing_types ::\n    const s_trailing_types = new Set @\n      trailing_types || ['comment_eol']\n    trailing_types = k => s_trailing_types.has(k)\n\n  for const ln of offside_lines ::\n    if ln.is_blank :: continue\n\n    const {len_dedent, len_indent, len_inner} = ln\n\n    const offside_dedent = @{}\n      type: 'offside_dedent'\n      len_dedent, len_indent\n\n    if len_inner ::\n      offside_dedent.len_inner = len_inner\n\n    const last = ln.content.pop()\n    if last.multiline || trailing_types(last.type) ::\n      ln.content.push @ offside_dedent, last\n    else ::\n      ln.content.push @ last, offside_dedent\n\n","\nconst SourceLocation = @{}\n  __proto__: null\n\n  get [Symbol.toStringTag]() :: return '«SourceLocation»'\n  toString() :: return `«${this.line}:${this.column}»`\n  get column() :: return this.pos - this.line_pos\n\n  create(source, file) ::\n    const root = @{}\n      line:0, pos:0, line_pos:0\n      __proto__: SourceLocation\n\n    if null != file ::\n      root.file = file\n\n    Object.defineProperties @ root, @{}\n      __root__: @{} value: root\n      source: @{} value: source\n    return Object.freeze @ root\n\n  nextLine() ::\n    let {line, pos} = this\n    line += 1\n    return Object.freeze @:\n      line, pos, line_pos: pos,\n      __proto__: this.__root__\n\n  move(char_len) ::\n    if 'string' === typeof char_len ::\n      char_len = char_len.length\n    else if 'number' === typeof char_len ::\n      char_len |= 0\n    else throw new TypeError('Expected move to be a string or number')\n\n    let {line, pos, line_pos} = this\n    pos += char_len\n    return Object.freeze @:\n      line, pos, line_pos,\n      __proto__: this.__root__\n\n  distance(other) ::\n    const lines = this.line - other.line\n    const chars = this.pos - other.pos\n    return @{} lines, chars\n\n  slice(other) ::\n    if this.source !== other.source ::\n      throw new Error @ `Locations from different sources`\n    return this.source.slice @ this.pos, other.pos\n\n  syntaxError(message) ::\n    const err = new SyntaxError(message)\n    err.src_loc = this\n    return err\n\nexport default SourceLocation.create\n","export const rx_lines = /(\\r\\n|\\r|\\n)/ ;\nexport const rx_indent = /^([ \\t]*)(.*)$/ ;\nexport const rx_indent_order = /^[\\t]*[ ]*$/ ;\n\nimport createLoc from './_location.jsy'\n\nexport default basic_offside_scanner\nexport function basic_offside_scanner(source, feedback) ::\n  if null == feedback ::\n    feedback = @{}\n      warn(msg, ...args) :: console.warn @ `[Offside Warning]:: ${msg}`, ...args\n\n  const all_lines = []\n  const q_raw_lines = source.split(rx_lines)\n\n  const offside_line_proto = @{}\n    __proto__: null\n    get source() ::\n      const {start, end} = this.loc\n      return start.slice(end)\n\n  let loc_tip = createLoc(source, feedback.file)\n  let rx_indent_choice = null\n\n  while 0 !== q_raw_lines.length ::\n    const loc = @{} start: loc_tip = loc_tip.nextLine()\n\n    const src_line = q_raw_lines.shift() || ''\n    loc.end = loc_tip = loc_tip.move(src_line)\n\n    const src_line_end = q_raw_lines.shift() || ''\n    loc_tip = loc_tip.move(src_line_end)\n\n\n    const match = rx_indent.exec(src_line)\n    const loc_indent = loc.start.move(match[1])\n    const is_blank = 0 === match[2].length\n\n    if ! rx_indent_order.test(match[1]) ::\n      throw loc.start.syntaxError @ `Mixed tab and space indent (${loc_indent})`, \n\n    const raw = @{}\n      line: src_line\n      line_end: src_line_end\n      indent: match[1]\n      content: match[2]\n\n    let node\n    if is_blank ::\n      node = @{}\n        type: 'offside_blank_line', loc\n        is_blank\n\n    else ::\n      const indent_node = @{}\n        type: 'offside_indent',\n        loc: @{}\n          start: loc.start\n          end: loc_indent\n        len_indent: match[1].length\n        indent: match[1]\n\n      const conent_node = @{}\n        type: 'offside_content',\n        loc: @{}\n          start: loc_indent\n          end: loc.end\n        len_indent: match[1].length\n        indent: match[1]\n        content: match[2]\n\n      node = @{}\n        __proto__: offside_line_proto\n        type: 'offside_line', loc\n        indent: indent_node\n        content: conent_node\n        len_indent: match[1].length\n\n    Object.defineProperties @ node, @{} raw: {value: raw}\n    all_lines.push @ node\n\n  add_indent_info(all_lines)\n  return all_lines\n\n\nfunction add_indent_info(all_lines) ::\n  let len_dedent=0\n  const len_stack = [0]\n  for let i = all_lines.length-1 ; i>=0 ; i-- ::\n    const ln = all_lines[i]\n    if ln.is_blank :: continue\n\n    ln.len_dedent = len_dedent\n    const len_indent = ln.len_indent\n\n    let len_inner\n    while len_stack[0] > len_indent ::\n      len_inner = len_stack.shift()\n\n    if len_stack[0] < len_indent ::\n      len_stack.unshift @ len_indent\n\n    if len_inner ::\n      ln.len_inner = len_inner\n\n    len_dedent = len_indent\n","\nexport function ensure_indent(ctx, scanner) ::\n  const ln_first = scanner.ln_first\n  if undefined === ln_first :: return true\n  const len_first_indent = ln_first.len_indent\n\n  const d_dedent = ctx.ln.len_indent - len_first_indent\n  if d_dedent < 0 ::\n    throw ctx.ln.indent.loc.end.syntaxError @\n      `Invalid indent level in ${scanner.description}. (${ctx.ln.indent.loc.end})  --  current indent: ${ctx.ln.len_indent}  start indent: ${len_first_indent} from (${ln_first.loc.start})`\n  else return true\n\n\nexport function ensure_progress(loc0, loc1) ::\n  if loc0.pos == loc1.pos ::\n    throw new Error @ `Scanner failed to make progress (${loc1})`\n\n  if loc0.pos > loc1.pos ::\n    throw new Error @ `Scanner went backward (${loc1} from ${loc0})`\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class DispatchScanner ::\n  constructor(disp_name) ::\n    this.disp_name = disp_name || 'root'\n    this.by_kind = {}\n    this.by_op = {}\n\n  startCompile() ::\n    Object.defineProperties @ this, @{}\n      rx_list: @{} value: (this.rx_list || []).slice()\n    this.by_kind = Object.assign @ {}, this.by_kind\n    this.by_op = Object.assign @ {}, this.by_op\n    return this\n\n  addScannerList(scannerList) ::\n    for const scanner of scannerList ::\n      if scanner ::\n        this.addScanner(scanner)\n    return this\n\n  addScanner(scanner) ::\n    if scanner.withDispatch ::\n      scanner = scanner.withDispatch(this)\n\n    if scanner.is_body ::\n      this.ds_body = scanner\n\n    this.by_op[scanner.op] = scanner\n\n  addRegExpScanner(scanner, kind, re_disp) ::\n    if kind ::\n      this.by_kind[kind] = scanner.op\n      this.rx_list.push @ new RegExp(re_disp, 'g')\n    return this\n\n  finishCompile(ds_body) ::\n    if undefined === ds_body ::\n      ds_body = this.ds_body\n    return Object.defineProperties @ this, @{}\n      ds_body: @{} value: ds_body, writable: true\n\n\n  cloneWithScanner(...scanners) ::\n    return this.cloneWithScannerList(scanners)\n  cloneWithScannerList(scanners) ::\n    const self = Object.create(this)\n    self.level = 1 + 0|self.level\n    self.description = self.description.replace @\n      /\\(\\d+\\)/, `(${self.level})`\n\n    self.startCompile()\n    self.addScannerList(scanners)\n    self.finishCompile()\n    return self\n\n\n  get_active_dispatch(ctx) ::\n    return ctx[`dispatch_${this.disp_name}`]\n  set_active_dispatch(ctx) ::\n    ctx.dispatch = ctx[`dispatch_${this.disp_name}`] = this\n\n\n  newline(ctx, is_blank) ::\n\n  scan(ctx, idx0) ::\n    const loc0 = ctx.loc_tip\n    const res = this._scan(ctx, idx0)\n    ensure_progress @ loc0, ctx.loc_tip\n    return res\n\n  _scan(ctx, idx0) ::\n    this.set_active_dispatch(ctx)\n\n    if undefined === this.ln_first ::\n      this.ln_first = ctx.ln\n\n    ensure_indent(ctx, this)\n\n    const source = ctx.ln_source // slice is done by setting lastIndex\n    let match=null, idx1 = Infinity\n\n    for const rx of this.rx_list ::\n      rx.lastIndex = idx0 // regexp powered source.slice()\n\n      const m = rx.exec(source)\n      if null !== m && m.index < idx1 ::\n        idx1 = m.index\n        match = m\n\n    if null === match ::\n      return this.ds_body.scan(ctx, idx0)\n\n    if idx0 !== idx1 ::\n      return this.ds_body.scan_fragment @\n        ctx, source.slice(idx0, idx1)\n\n    const kind = match.filter(Boolean)[1]\n    const op = this.by_kind[kind]\n    const op_scanner = this.by_op[op]\n    if ! op_scanner ::\n      throw new Error @ `No scanner registered for « ${kind} »`\n\n    return op_scanner.scan(ctx, idx1)\n\n  scan_fragment(ctx, content) ::\n    throw new Error @ `${this.description} does not support fragments`\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class DispatchFirstlineScanner extends DispatchScanner ::\n  scan(ctx, idx0) ::\n    ctx.scanner = this.ds_body\n    return super.scan(ctx, idx0)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class EmbeddedDispatchScanner extends DispatchScanner ::\n  constructor(options) ::\n    super @ options.disp_name\n    Object.assign(this, options)\n    this._compileForInit()\n\n  _compileForInit() ::\n    this.startCompile()\n    this.addScannerList(this.scannerList)\n    this.finishCompile()\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class BaseSourceScanner ::\n  constructor(options) ::\n    Object.assign(this, options)\n    this._compileForInit()\n\n  _compileForInit() ::\n\n  withDispatch(ds) :: return this\n\n  emit_ast(ctx, content, ast_type) ::\n    const start = ctx.loc_tip\n    const end = ctx.loc_tip = start.move(content || 0)\n    const ast = @{} type: ast_type || this.op, loc: {start, end}, content\n    this._ast_extend(ctx, ast)\n    ctx.parts.push @ ast\n    return ast\n\n  _ast_extend(ctx, ast) ::\n\n  newline(ctx, is_blank) ::\n  scan_fragment(ctx, content) ::\n    throw new Error @ `Scanner (${this.description}) does not support fragments`\n  scan(ctx, idx0) ::\n    throw new Error @ `Scanner (${this.description}) does not support scans`\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class SourceCodeScanner extends BaseSourceScanner ::\n  get is_body() :: return true\n\n  scan_fragment(ctx, content) ::\n    this.scan_content @ ctx, content\n\n  scan(ctx, idx0) ::\n    this.scan_content @ ctx, ctx.ln_source.slice(idx0)\n\n  scan_content(ctx, content) ::\n    if content ::\n      this.emit_ast @ ctx, content\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class NestedCodeScanner extends SourceCodeScanner ::\n  constructor(options) ::\n    super(options)\n    if ! this.char_pairs ::\n      throw new Error @ 'Missing required char_pairs mapping'\n\n    const chars = Object.keys(this.char_pairs).join('\\\\')\n    this.rx = new RegExp(`([${chars}])`)\n\n  withOuter(options) ::\n    const scanner = options.scanner\n    if 'function' !== typeof scanner.scan ::\n      throw new Error @ `Expected valid outer scanner`\n    delete options.scanner\n\n    const self = Object.create @ this, @{}\n      restore_scanner: @{} value: scanner\n    Object.assign @ self, options\n    return self\n\n  scan_content(ctx, nested_content) ::\n    const {stack, char_pairs} = this\n\n    let content = ''\n    for const tok of nested_content.split(this.rx) ::\n      const p = 1 === tok.length ? char_pairs[tok] : undefined\n\n      if undefined === p ::\n        content += tok\n        continue\n\n      if true === p ::\n        content += tok\n        stack.push @ tok\n        continue\n\n      const tip = stack.pop()\n      if tip !== p ::\n        const loc = ctx.loc_tip.move(content)\n        throw loc.syntaxError @\n          `Mismatched nesting in ${this.description} (${loc})`\n\n      if 0 !== stack.length ::\n        content += tok\n        continue\n\n      if content ::\n        this.emit_ast @ ctx, content\n      this.emit_ast @ ctx, tok, this.ast_end || 'nested_end'\n      ctx.scanner = this.restore_scanner\n      return\n\n    // all tokens with non-zero stack\n    if content ::\n      this.emit_ast @ ctx, content\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class RegExpScanner extends BaseSourceScanner ::\n\n  _compileForInit() ::\n    const {rx_open, rx_close} = this\n    const rx_disp = new RegExp @\n      (rx_open ? rx_open.source : '') + rx_close.source\n\n    const rx_resume = new RegExp @\n      '^' + rx_close.source\n\n    Object.defineProperties @ this, @{}\n      rx_disp: @{} value: rx_disp\n      rx_resume: @{} value: rx_resume\n\n  withDispatch(ds) ::\n    this.compileForDispatch(ds)\n    return this\n\n  compileForDispatch(ds) ::\n    if undefined === this.kind :: return\n\n    const match = this.rx_disp.exec @ this.example\n    if null === match || this.kind !== match[1] || null == match[2] ::\n      throw new Error @ `Invalid scanner regexp and/or example (${this.description})`\n\n    ds.addRegExpScanner @ this, this.kind, this.rx_disp.source\n\n\n\n  newline(ctx, is_blank) ::\n    if ! this.multiline && ! this.allow_blank_close ::\n      throw ctx.ln.loc.end.syntaxError @\n        `Newline in ${this.description} (${ctx.ln.loc.end})`\n\n  _ast_extend(ctx, ast) ::\n    const ln = this.ln_first || ctx.ln\n    if undefined !== ln.len_inner ::\n      ast.block_indent = ln.len_inner\n    return ast\n\n  scan(ctx, idx0) ::\n    const match = this.rx_disp.exec @ ctx.ln_source.slice(idx0)\n    if null === match ::\n      throw ctx.loc_tip.syntaxError @\n        `Invalid scan ${this.description}. (${ctx.loc_tip})`\n\n    const [content, open, close] = match\n\n    const t_content = this.nestTrim(content, close, false)\n    if t_content :: this.emit_ast @ ctx, t_content\n    return this.post_scan(ctx, close)\n\n  scan_continue(ctx, idx0) ::\n    ensure_indent(ctx, this)\n\n    const match = this.rx_resume.exec @ ctx.ln_source.slice(idx0)\n    if null === match ::\n      throw ctx.loc_tip.syntaxError @\n        `Invalid scan continue ${this.description}. (${ctx.loc_tip})`\n\n    const [content, close] = match\n\n    const t_content = this.nestTrim(content, close, true)\n    if t_content :: this.emit_ast @ ctx, t_content\n    return this.post_scan(ctx, close)\n\n  nestTrim(content, close, isContinue) ::\n    const nestingTrim = this.nestingTrim\n    if undefined !== nestingTrim ::\n      let trim = nestingTrim[close]\n      if true === trim :: trim = close\n      if trim :: return content.slice(0, - trim.length)\n\n    return content\n\n  post_scan(ctx, close) ::\n    if ! close ::\n      if this.invert_close ::\n        // e.g. no '\\' continuations at end of line\n        return true\n\n      if ! this.allow_blank_close ::\n        ctx.scanner = this.continueScanner(ctx)\n      return\n\n    else if this.invert_close ::\n      // e.g. '\\' continuations at end of line\n      ctx.scanner = this.continueScanner(ctx)\n\n    return this.nestMatch @ close,\n      ctx, this.hostScanner || this\n\n  nestMatch(close, ctx, hostScanner) ::\n    const nesting = this.nesting\n    if undefined !== nesting ::\n      return this.nestWith @\n        nesting[close],\n        ctx, hostScanner\n    return true // pop ctx.scanner\n\n  nestWith(nested, ctx, hostScanner) ::\n    if true === nested || undefined === nested || null === nested ::\n      return true // pop ctx.scanner\n\n    else if hostScanner === nested || 'host' === nested ::\n      ctx.scanner = hostScanner.continueScanner(ctx)\n      return\n\n    else if 'function' === typeof nested.nestedScanner ::\n      ctx.scanner = nested.nestedScanner(ctx)\n      return\n\n    else if 'function' === typeof nested ::\n      return nested @ ctx, hostScanner\n\n    return nested\n\n\n  nestedScanner(ctx) ::\n    return this._asNestedScanner @ ctx, 'nest', @{}\n\n  continueScanner(ctx) ::\n    return this._asNestedScanner @ ctx, 'cont', @{}\n      op: this.op_continue || this.op\n      continueScanner(ctx) :: return this\n      scan(ctx, idx0) ::\n        this.scan_continue(ctx, idx0)\n\n  _asNestedScanner(ctx, desc, body) ::\n    const restore_scanner = ctx.scanner\n    const self = @{}\n      __proto__: this\n      description: `${this.description} (${desc})`\n      ln_first: ctx.ln_first || ctx.ln\n\n      _pop_scanner(ctx) ::\n        if this.op_pop ::\n          this.emit_ast @ ctx, '', this.op_pop\n        ctx.scanner = restore_scanner\n\n      scan(ctx, idx0) ::\n        if true === super.scan(ctx, idx0) ::\n          this._pop_scanner(ctx)\n\n      scan_continue(ctx, idx0) ::\n        if true === super.scan_continue(ctx, idx0) ::\n          this._pop_scanner(ctx)\n\n    return Object.assign @ self, body\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class MultiLineScanner extends RegExpScanner ::\n  newline(ctx, is_blank) ::\n  get multiline() :: return true\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class TaggedRegExpScanner extends RegExpScanner ::\n  withTag(ctx, tag, hostScanner) ::\n    const rx_replace = this.rx_replace || /tag/g\n\n    const re_open = this.rx_open.source\n      .replace @ rx_replace, tag\n    const re_close = this.rx_close.source\n      .replace @ rx_replace, tag\n\n    const rx_open = new RegExp @ re_open\n    const rx_close = new RegExp @ re_close\n    const rx_disp = new RegExp @ re_open + rx_close.source\n    const rx_resume = new RegExp @ '^' + re_close\n\n    const self = @{} __proto__: this, hostScanner,\n      rx_open, rx_close, rx_resume, rx_disp,\n      tag, ln_first: ctx.ln\n      compileForDispatch(ds) ::\n        // skip testing example for second pass of this object\n        ds.addRegExpScanner @ this, this.kind, this.rx_disp.source\n\n    self.tagScanner(ctx, tag, hostScanner)\n    return self\n\n  tagScanner(ctx, tag, hostScanner) ::\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class DynamicScanner extends MultiLineScanner ::\n  scan(ctx, idx0) ::\n    const leader_match = this.rx_disp.exec @ ctx.ln_source.slice(idx0)\n\n    const self = this.withLeaderTag @ ctx, leader_match[2]\n    return self._leader.scan(ctx, idx0)\n\n  withLeaderTag(ctx, tag) ::\n    const self = @{}\n      __proto__: this\n      __root__: this.__root__ || this\n      ln_first: ctx.ln\n\n    self._trailer = this.trailer && this.trailer.withTag @ ctx, tag, self\n    self._leader = this.leader.withTag @ ctx, tag, self\n    return self\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class EmbeddedDynamicScanner extends DynamicScanner ::\n  continueScanner(ctx) ::\n    ensure_indent(ctx, this)\n    const ds_body = this.ds_body.cloneWithScanner @ this._trailer\n\n    // inherit ln_first\n    ds_body.ln_first = \n      ds_body.disp_name === ctx.dispatch.disp_name\n        ? ctx.dispatch.ln_first\n        : this.ln_first || ctx.ln\n\n    return ds_body\n\n  andDispatchWith(options) ::\n    options.scannerList = options.scannerList.concat @# this\n    const ds_body = new EmbeddedDispatchScanner(options)\n    this.ds_body = ds_body\n    return ds_body\n\n","import { DispatchScanner, DispatchFirstlineScanner } from './context_scanner.jsy'\n\nexport default bind_context_scanner\nexport function bind_context_scanner(context_scanners) ::\n  if ! Object.isFrozen(context_scanners) || ! Array.isArray(context_scanners) ::\n    throw new TypeError @ `Expected a frozen array of context scanners`\n\n  const cache = bind_context_scanner.cache || new WeakMap()\n  if cache !== bind_context_scanner.cache ::\n    bind_context_scanner.cache = cache\n\n  let res = cache.get(context_scanners)\n  if undefined === res ::\n    res = compile_context_scanner(context_scanners)\n    cache.set(context_scanners, res)\n  return res\n\n\nfunction compile_context_scanner(context_scanners) ::\n  const ds_first = build_composite_scanner(context_scanners)\n  return context_scanner\n\n  function context_scanner(offside_lines) ::\n    const ctx = @{} scanner: ds_first\n\n    for const ln of offside_lines ::\n      if ln.is_blank ::\n        delete ln.content\n        ctx.scanner.newline(ctx, true)\n        continue\n\n\n      ctx.parts = []\n      ctx.ln = ln\n\n      scan_source(ctx, ln.content)\n\n      if 0 === ctx.parts.length ::\n        throw new Error @ `No parts generated by context scanner`\n\n      ln.content = ctx.parts\n      ctx.scanner.newline(ctx, false)\n\n    ctx.scanner.newline(ctx, true)\n    return offside_lines\n\n\n  function scan_source(ctx, ln_content) ::\n    const ln_source = ctx.ln_source = ln_content.content\n    const loc_start = ctx.loc_tip = ctx.loc_start = ln_content.loc.start\n    const pos0 = loc_start.pos\n\n    while true ::\n      const idx0 = ctx.loc_tip.pos - pos0\n      if idx0 >= ln_source.length ::\n        return // done with this line\n\n      ctx.scanner.scan @ ctx, idx0\n\n\n  function build_composite_scanner() ::\n    const ds_body = new DispatchScanner().startCompile()\n    ds_body.description = 'Dispatch scanner (0)'\n    const ds_first = new DispatchFirstlineScanner().startCompile()\n    ds_first.description = 'Firstline Dispatch scanner (0)'\n\n    for const scanner of context_scanners ::\n      if ! scanner :: continue\n\n      const ds = scanner.firstline ? ds_first : ds_body\n      ds.addScanner(scanner)\n\n    ds_body.finishCompile()\n    return ds_first.finishCompile(ds_body)\n\n","import basic_offside_scanner from './basic_offside.jsy'\nimport bind_context_scanner from './basic_contexts.jsy'\n\nexport default scan_offside_contexts\nexport function scan_offside_contexts(source, feedback, disp_name, context_scanners) ::\n  // see scan_javascript and scan_clike for good context_scanners\n  const context_scanner = bind_context_scanner(disp_name, context_scanners)\n  return context_scanner @ basic_offside_scanner(source, feedback)\n\n","import { SourceCodeScanner, NestedCodeScanner, RegExpScanner, MultiLineScanner } from './context_scanner.jsy'\nimport scan_offside_contexts from './basic_offside_contexts.jsy'\n\nexport const scanner_source =\n  new SourceCodeScanner @:\n      description: 'Source Code Scanner'\n      op: 'src'\n\nexport const scanner_nestedSrc =\n  new NestedCodeScanner @:\n    op: 'src', description: 'Template parameter source'\n    char_pairs: @{}\n      '{': true, '}': '{'\n      '(': true, ')': '('\n      '[': true, ']': '['\n\nexport const scanner_hashbangDirective =\n  new RegExpScanner @:\n      description: 'Hashbang directive'\n      example: '#!/usr/bin/env node'\n      op: 'hashbang', kind:'#!'\n      rx_open: /^(#!)/, rx_close: /.*($)/,\n      firstline: true\n      allow_blank_close: true\n\nexport const scanner_commentEOL =\n  new RegExpScanner @:\n      description: 'Comment to end of line'\n      example: '// comment'\n      op: 'comment_eol', kind:'//'\n      rx_open: /(\\/\\/)/, rx_close: /.*($)/,\n      allow_blank_close: true\n\nexport const scanner_commentMultiLine =\n  new MultiLineScanner @:\n      description: 'Multi-line comment'\n      example: '/* comment */'\n      op: 'comment_multi', kind:'/*'\n      rx_open: /(\\/\\*)/, rx_close: /.*?(\\*\\/|$)/,\n\nexport const scanner_strSingle =\n  new RegExpScanner @:\n      description: 'Single quote string literal'\n      example: \"'single quote'\"\n      op: 'str1', kind:\"'\"\n      rx_open: /(')/, rx_close: /(?:\\\\.|[^'])*('|$)/,\n\nexport const scanner_strDouble =\n  new RegExpScanner @:\n      description: 'Double quote string literal'\n      example: '\"double quote\"'\n      op: 'str2', kind:'\"'\n      rx_open: /(\")/, rx_close: /(?:\\\\.|[^\"])*(\"|$)/,\n\nexport const scanner_preprocessor =\n  new RegExpScanner @:\n      description: 'Preprocessor directive'\n      example: '# IF platform === \"web\"'\n      op: 'preprocessor', kind:'#'\n      rx_open: /^\\s*(#)/, rx_close: /.*?([\\\\]?)\\s*$/,\n      invert_close: true // preprocessor uses '\\' continuations\n      allow_blank_close: true\n\n\nexport const clike_context_scanners = Object.freeze @#\n  scanner_source\n  scanner_hashbangDirective\n  scanner_commentEOL\n  scanner_commentMultiLine\n  scanner_strSingle\n  scanner_strDouble\n  scanner_preprocessor\n\n\nexport default scan_clike\nexport function scan_clike(source, feedback) ::\n  return scan_offside_contexts(source, feedback, clike_context_scanners)\n\n","import scan_offside_contexts from './basic_offside_contexts.jsy'\nimport { RegExpScanner, MultiLineScanner } from './context_scanner.jsy'\nimport { clike_context_scanners, scanner_nestedSrc } from './scan_clike.jsy'\n\n\nexport const scanner_regexp =\n  new RegExpScanner @:\n      description: 'RegExp literal'\n      example: '/regexp/'\n      op: 'regexp'\n      kind: '/'\n      rx_open: /(\\/)(?![\\/\\*])(?:\\\\.|[^\\\\\\/])+(?=\\/)/\n      rx_close: /(\\/[a-z]*)/\n\n\n\nexport const scanner_strTemplate =\n  new MultiLineScanner @:\n      description: 'Template string literal'\n      example: '`template string`'\n      op: 'str_template'\n      kind: '`'\n      rx_open: /(`)/\n      rx_close: /(?:\\\\.|\\$(?!{)|[^\\$`\\\\])*(`|\\${|$)/\n      nesting: @{}\n        '${': templateArgNesting\n\nfunction templateArgNesting(ctx, hostScanner) ::\n  const src = scanner_nestedSrc.withOuter @:\n    scanner: hostScanner.continueScanner(ctx)\n    stack: @[] '{' // from the template parameter opening\n    ast_end: 'template_param_end'\n\n  src.emit_ast @ ctx, '', 'template_param'\n\n  ctx.scanner = ctx.dispatch_root.cloneWithScanner(src)\n\n\n\nexport const js_context_scanners = Object.freeze @ clike_context_scanners.concat @#\n  scanner_regexp\n  scanner_strTemplate\n\nexport default scan_javascript\nexport function scan_javascript(source, feedback) ::\n  return scan_offside_contexts(source, feedback, js_context_scanners)\n\n","import scan_offside_contexts from './basic_offside_contexts.jsy'\nimport { js_context_scanners } from './scan_javascript.jsy'\nimport { scanner_nestedSrc } from './scan_clike.jsy'\nimport { SourceCodeScanner, RegExpScanner } from './context_scanner.jsy'\nimport { EmbeddedDynamicScanner, TaggedRegExpScanner } from './context_scanner.jsy'\n\n\nexport const scanner_jsxContent =\n  new SourceCodeScanner @:\n      description: 'JSX Content Scanner'\n      op: 'jsx_content'\n\nexport const scanner_jsxContentExpr =\n  new RegExpScanner @:\n      description: 'JSX Content Expression'\n      example: '{ param }'\n      op: 'jsx_content_expr'\n      kind: '{'\n      rx_open: /({)/,\n      rx_close: /.*()/,\n\n      nestTrim(content, close) :: return ''\n      post_scan(ctx) :: jsxArgNesting @ ctx, null\n\nexport const scanner_jsxAttrName =\n  new RegExpScanner @:\n      description: 'JSX attribute name'\n      op: 'jsx_attr_name'\n      rx_open: /([a-zA-Z0-9_:.\\-]+)/,\n      rx_close: /\\s*(=)\\s*/,\n\nexport const scanner_jsxAttrSingle =\n  new RegExpScanner @:\n      description: 'JSX Single quote attribute literal'\n      multiline: true\n      op: 'jsx_attr_str1'\n      rx_open: /\\s*(')/,\n      rx_close: /(?:\\\\.|[^'])*(')\\s*/,\n\nexport const scanner_jsxAttrDouble =\n  new RegExpScanner @:\n      description: 'JSX Double quote attribute literal'\n      multiline: true\n      op: 'jsx_attr_str2'\n      rx_open: /\\s*(\")/,\n      rx_close: /(?:\\\\.|[^\"])*(\")\\s*/,\n\nexport const scanner_jsxTagClose =\n  new TaggedRegExpScanner @:\n      description: 'JSX Close Tag'\n      example: '</tag>'\n      op: 'jsx_tag_close'\n      kind: '</'\n      multiline: true\n      rx_open: /(<\\/)\\s*/\n      rx_close: /([a-zA-Z0-9_:.\\-]+)\\s*>/\n\n      tagScanner(ctx) ::\n        this.restore_scanner = ctx.scanner\n\n      post_scan(ctx, close) ::\n        if close !== this.tag ::\n          throw ctx.loc_tip.syntaxError @\n            `Mismatched JSX close tag \"</${close}>\", expected \"</${this.tag}>\". (${ctx.loc_tip})`\n\n        ctx.scanner = this.restore_scanner\n\n\n\nexport const scanner_jsxTag =\n  new TaggedRegExpScanner @:\n      description: 'JSX Tag'\n      multiline: true\n      op: 'jsx_tag'\n      op_continue: 'jsx_tag_part'\n\n      rx_open: /(<)tag\\s*/\n      rx_close: /\\s*($|\\/?>|[{'\"]|[a-zA-Z0-9_:.\\-]+=)/\n\n      nesting: @{}\n        '>': 'host' // use hostScanner\n        '/>': true // pop ctx.scanner\n\n      nestingEnd: @{}\n        '{': jsxArgNesting\n        '=': scanner_jsxAttrName\n        \"'\": scanner_jsxAttrSingle\n        '\"': scanner_jsxAttrDouble\n\n      nestTrim(content, close, isContinue) ::\n        if this.nestingEnd[close.slice(-1)] ::\n          return content.slice(0, - close.length)\n        return content\n      nestMatch(close, ctx, hostScanner) ::\n        let inner = this.nesting[close]\n        if undefined === inner ::\n          inner = this.nestingEnd[close.slice(-1)]\n\n        if true !== inner && 'host' !== inner ::\n          // we're actually pushign two scanners onto the stack\n          // the first for this context, the second for the attribute\n          ctx.scanner = hostScanner = this.continueScanner(ctx)\n\n        return this.nestWith @ inner, ctx, hostScanner\n\nfunction jsxArgNesting(ctx, hostScanner) ::\n  const src = scanner_nestedSrc.withOuter @:\n    scanner: null !== hostScanner\n      ? hostScanner.continueScanner(ctx)\n      : ctx.scanner\n    stack: @[] '{' // from the jsx parameter opening\n    ast_end: 'jsx_param_end'\n\n  src.emit_ast @ ctx, '{', 'jsx_param'\n\n  ctx.scanner = ctx.dispatch_root.cloneWithScanner(src)\n\n\n\n\nexport const scanner_jsx =\n  new EmbeddedDynamicScanner @:\n      description: 'Embedded JSX expression'\n      example: '<section>content</section>'\n      kind:'<'\n      disp_name: 'jsx'\n      op: 'jsx'\n\n      // recognize by '<tag' followed by 'attr=' or '/>' or '>'\n      rx_open: /(<)([a-zA-Z0-9_:.\\-]+)\\s*(\\/?>|[{]|[a-zA-Z0-9_:\\-]+=|$)/\n      rx_close: /.*$/\n\n      leader: scanner_jsxTag\n      trailer: scanner_jsxTagClose\n\n\nexport const scanner_embedded_jsx =\n  scanner_jsx.andDispatchWith @:\n    description: 'JSX Dispatch Scanner (0)'\n    disp_name: 'jsx'\n\n    scannerList: @[]\n      scanner_jsxContent\n      scanner_jsxContentExpr\n\nexport const scanner_jsx_close_fragment =\n  new RegExpScanner @:\n      description: 'Embedded JSX fragment close expression'\n      example: '</>'\n      op: 'jsx_frag_close'\n      kind: '</'\n      allow_blank_close: true\n\n      rx_open: /(<\\/)\\s*/\n      rx_close: /([a-zA-Z0-9_:.\\-]*)\\s*>/\n\n      post_scan(ctx, close) ::\n        if close ::\n          throw ctx.loc_tip.syntaxError @\n            `Mismatched JSX fragment close tag \"</${close}>\", expected \"</$>\". (${ctx.loc_tip})`\n\n        ctx.scanner = this.restore_scanner\n\nexport const scanner_jsx_fragment =\n  new RegExpScanner @:\n      description: 'Embedded JSX fragment expression'\n      example: '<></>'\n      op: 'jsx_frag'\n      kind: '<>'\n\n      rx_open: /(<>)/\n      rx_close: /.*($|<\\/>)/\n\n      nestTrim(content, close, isContinue) ::\n        return '<>'\n\n      post_scan(ctx) ::\n        const jsx_frag_close = @{}\n          __proto__: scanner_jsx_close_fragment\n          restore_scanner: ctx.scanner\n\n        const ds_body = \n          scanner_embedded_jsx.cloneWithScanner @\n            jsx_frag_close\n\n        ds_body.description = 'Fragment' + ds_body.description\n        const disp = ds_body.get_active_dispatch(ctx)\n        ds_body.ln_first = disp && disp.ln_first || ctx.ln\n\n        ctx.scanner = ds_body\n\n\n\n\nexport const jsx_context_scanners = Object.freeze @ js_context_scanners.concat @#\n  scanner_jsx_fragment\n  scanner_jsx\n\nexport default scan_javascript_with_jsx\nexport function scan_javascript_with_jsx(source, feedback) ::\n  return scan_offside_contexts(source, feedback, jsx_context_scanners)\n\n\n","import { rx_offside_ops, rx_keyword_ops, rx_unknown_ops } from './jsy_regexp.jsy'\nimport inject_dedent from './scanner/inject_dedent.jsy'\nimport scan_jsx_javascript from './scanner/scan_jsx_javascript.jsy'\n\nexport default scan_jsy\nexport function scan_jsy(source, feedback) ::\n  const jsy_ast = scan_jsx_javascript(source, feedback)\n  inject_dedent @ jsy_ast, @[] 'comment_eol'\n\n  for const ln of jsy_ast ::\n    if ln.is_blank :: continue\n\n    const parts = transform_jsy_ops(ln.content, ln)\n    ln.content = parts\n\n    const idx_dedent = parts.findIndex @ p => 'offside_dedent' === p.type\n    const last = parts[idx_dedent - 1]\n    if undefined === last :: continue\n\n    if last.type.startsWith('jsy_op') ::\n      parts[idx_dedent].ends_with_jsy_op = true\n      last.ending_jsy_op = true\n\n  return jsy_ast\n\n\n\nfunction transform_jsy_ops(parts, ln) ::\n  const res = []\n\n  for let p, i=0; undefined !== (p = parts[i]) ; i++ ::\n    if 'src' === p.type ::\n      transform_jsy_part(res, p, ln)\n    else res.push(p)\n\n\n  // allow keywords at the start and in code blocks after \"::\"\n  let kw_allowed = 'src' === res[0].type\n  for let idx=0 ; undefined !== res[idx] ; idx ++ ::\n    if kw_allowed ::\n      transform_jsy_keyword(res, idx, ln)\n      kw_allowed = false\n\n    else if 'jsy_op' === res[idx].type ::\n      kw_allowed = '::' === res[idx].op\n\n  return res\n\n\n\nfunction transform_jsy_keyword(res, idx, ln) ::\n  const first = res[idx]\n\n  rx_keyword_ops.lastIndex = 0\n  const kw_match = rx_keyword_ops.exec(first.content)\n  if ! kw_match :: return false\n\n  const rest = kw_match.input.slice @ rx_keyword_ops.lastIndex\n  if '(' === rest[0] ::\n    return res // explicit keyword arguments\n\n  const kw_start = first.loc.start\n  const kw_end = kw_start.move @ kw_match[0]\n  const kw = kw_match[0].split(' ').filter(Boolean).join(' ')\n\n  const after = rest ? null : res[1+idx]\n  const explicit = after && 'jsy_op' === after.type && '@' === after.op\n\n  const kw_node = @{}\n    type: 'jsy_kw', kw, \n    loc: @{} start: kw_start, end: kw_end\n    len_indent: ln.len_indent\n    explicit\n\n  const post_node = as_src_ast @ rest, kw_end, first.loc.end\n\n  res.splice @ idx, 1, kw_node, post_node\n  return true\n\n\nfunction transform_jsy_part(res, part, ln) ::\n  ::\n    rx_offside_ops.lastIndex = 0\n\n    let loc_tip = part.loc.start\n    while true ::\n      let start = loc_tip, idx0 = rx_offside_ops.lastIndex\n      const op_match = rx_offside_ops.exec(part.content)\n\n      if ! op_match ::\n        _tail(loc_tip, idx0)\n        return res\n\n      if idx0 < op_match.index ::\n        start = loc_tip = _inner(loc_tip, idx0, op_match.index)\n        idx0 = rx_offside_ops.lastIndex\n\n\n      const op = op_match[0].trim()\n      const end = loc_tip = loc_tip.move(op_match[0])\n\n      const op_part = @{}\n        type: 'jsy_op', op\n        loc: @{} start, end\n        len_indent: ln.len_indent\n        content: op_match[0]\n\n      const op_args = op_match.slice(1).filter(Boolean)\n      if op_args.length ::\n        op_part.type = 'jsy_op_args'\n        op_part.op_args = op_args\n        op_part.op = op_args.reduce @\n          (op, p) => op.replace(p, ''), op\n\n      res.push @ op_part\n\n  function _unknown_ops(content, loc_tip, idx0) ::\n    rx_unknown_ops.lastIndex = idx0\n    const op_unknown = rx_unknown_ops.exec(content)\n    if op_unknown ::\n      const op = op_unknown[0].trim()\n      const start = loc_tip\n      const end = loc_tip = loc_tip.move(op_unknown[0])\n      res.push @:\n        type: 'jsy_unknown', op\n        loc: @{} start, end\n        len_indent: ln.len_indent\n        content: op_unknown[0]\n\n  function _inner(loc_tip, idx0, idx_content) ::\n    const pre = part.content.slice(idx0, idx_content)\n    _unknown_ops(pre, loc_tip, idx0)\n\n    const start = loc_tip\n    const end = loc_tip.move(pre)\n    res.push @ as_src_ast @ pre, start, end\n    return end\n\n  function _tail(loc_tip, idx0) ::\n    const rest = part.content.slice(idx0)\n    if rest ::\n      _unknown_ops(rest, loc_tip, idx0)\n\n      const start = loc_tip\n      const end = start.move(rest)\n      res.push @ as_src_ast @ rest, start, end\n\nfunction as_src_ast(content, start, end) ::\n  return @{} type: 'src', loc: {start, end}, content\n\n","import { at_offside_map, extra_jsy_ops  } from './jsy_operators.jsy'\nimport { createTransform, applyPreprocessor } from './preprocess_jsy.jsy'\nimport checkOptionalComma from './optional_comma.jsy'\nimport scan_jsy from './scan_jsy.jsy'\n\nconst rx_leading_space = /^[ \\t]+/ ;\n\ntranspile_jsy.transpile_jsy = transpile_jsy\ntranspile_jsy.jsy_transpile = transpile_jsy\n\nexport default transpile_jsy\nexport const jsy_transpile = transpile_jsy\nexport function transpile_jsy(jsy_ast, feedback) ::\n  if ! feedback :: feedback = {}\n  if 'string' === typeof jsy_ast ::\n    jsy_ast = scan_jsy(jsy_ast, feedback)\n\n  const visitor = @{} __proto__: transpile_visitor\n\n  if feedback.checkOptionalComma ::\n    visitor._checkOptionalComma = visitor.checkOptionalComma\n    visitor.checkOptionalComma = feedback.checkOptionalComma\n\n  if feedback.addSourceMapping ::\n    Object.defineProperties @ visitor, @{}\n      addSourceMapping: @{} value: feedback.addSourceMapping\n\n  const preprocess = applyPreprocessor(feedback)\n  if 'function' === typeof preprocess ::\n    visitor.preprocess = preprocess\n\n  const lines = []\n  visitor.start()\n\n  for const ln of jsy_ast ::\n    if ln.is_blank ::\n      visitor.blank_line(ln)\n      lines.push @ ''\n      continue\n\n    visitor.start_line(ln)\n    visitor.v$offside_indent(ln.indent)\n\n    let prev = ln.indent\n    for const part of ln.content ::\n      const key = `v$${part.type}`\n\n      if undefined === visitor[key] ::\n        throw new Error @ `JSY transpile function \"${key}\" not found`\n\n      visitor[key] @ part, ln, prev\n      prev = part\n\n    const fin = visitor.finish_line(ln)\n    lines.push @ Array.isArray(fin) ? fin.join('') : fin || ''\n\n  visitor.finish()\n\n  if feedback.inlineSourceMap ::\n    const srcmap = feedback.inlineSourceMap()\n    if srcmap ::\n      lines.push @ '', sourcemap_comment @ srcmap\n\n  return lines.join('\\n')\n\n    \n\nconst root_head = Object.freeze @: __proto__: null\n\nconst transpile_visitor = @{}\n  __proto__: null\n  start() ::\n    this.lineno = 0\n    this.head = root_head\n\n  finish() ::\n    this._xform_start_line(null)\n    if root_head !== this.head ::\n      throw new Error @ 'Excess stack at finish'\n\n  blank_line(ln) ::\n    this.lineno ++\n\n  start_line(ln) ::\n    this.lineno ++\n    this.cur_ln = ln\n    this._cur = []\n\n    this._xform_start_line(ln)\n\n  finish_line(ln) ::\n    let line_src = this._cur\n    if 'function' === typeof line_src.finish_commas ::\n      line_src = line_src.finish_commas(line_src)\n\n    const comma_body = this.head.comma_body\n    if undefined !== comma_body ::\n      comma_body.push @ '\\n'\n\n    return this._xform_finish_line(line_src, ln)\n\n  emit_raw(src) ::\n    if src :: this._cur.push @ src\n\n  emit(src, loc_start) ::\n    if loc_start && this.addSourceMapping ::\n      const column = this._cur.join('').length\n      this.addSourceMapping @:\n        generated: @{} line: this.lineno, column\n        original: @{} line: loc_start.line, column: loc_start.column\n\n    const comma_body = this.head.comma_body\n    if undefined !== comma_body ::\n      comma_body.push @ src\n\n    this._cur.push @ src\n\n  emit_indent(indent) ::\n    const cur = this._cur\n    if 0 !== cur.length ::\n      throw new Error @ `Indent must be first element of cur list`\n\n    const comma_body = this.head.comma_body\n    if undefined === comma_body ::\n      cur.push @ indent\n      return\n\n    comma_body.splice @ 0, comma_body.length,\n      comma_body.join('').trimLeft()\n\n    if comma_body.len_inner != this.cur_ln.len_indent ::\n      cur.push @ indent\n      return\n\n    cur.push @ indent || ' '\n\n    cur.finish_commas = cur => ::\n      const pre = comma_body[0]\n      if ! pre :: return cur\n\n      const post = comma_body.slice(1).join('')\n      const opt_comma = this.checkOptionalComma @ comma_body.op, pre, post\n      if opt_comma ::\n        if cur[0].length > 1 ::\n          cur[0] = cur[0].replace(/\\s\\s$/, ', ')\n        else cur[0] = ','\n        comma_body.shift()\n      return cur\n\n  checkOptionalComma\n\n  stack_push(op, p) ::\n    if op.foldTop && this.head.isFoldable ::\n      this.stack_pop()\n\n    if null === op.post ::\n      if op.pre :: this.emit @ op.pre\n      return\n\n    const {len_indent, loc} = p\n    const head = @{} __proto__: this.head\n      op, len_indent, loc\n      isFoldable: op.isFoldable\n      nestBreak: op.nestBreak\n\n    if true === op.implicitCommas ::\n      const comma_body = head.comma_body = []\n      comma_body.op = op\n      comma_body.len_inner = this.cur_ln.len_inner\n    else head.comma_body = undefined\n\n    if op.in_nested_block ::\n      head.in_nested_block = true\n      head.nested_block_indent = len_indent\n\n    head.tail = [this.head].concat(head.tail || [])\n\n    const src = head.op.pre\n    if src :: this.emit @ src\n\n    this.head = head\n\n  stack_pop(c) ::\n    const head = this.head\n    const next = head.tail[0]\n    this.head = next\n\n    if head.op.implicitCommas && next.comma_body ::\n      // internal op was an expression; simplify for comma_body\n      next.comma_body.push(' expr ')\n\n    const src = head.op.post\n    if src ::\n      this.emit @ c ? ' '+src : src\n\n  v$jsy_unknown(p) ::\n    throw p.loc.start.syntaxError @\n      `JSY unknown operator \"${p.op}\"`\n\n  v$jsy_kw(p) ::\n    const kw_op = p.explicit\n      ? extra_jsy_ops.kw_explicit\n      : extra_jsy_ops.kw_normal\n\n    this.stack_push @ kw_op.kwExpandOp(p), p\n\n  v$jsy_op(p) ::\n    this._jsy_op @ at_offside_map[p.op], p\n\n  v$jsy_op_args(p) ::\n    this._jsy_op @ at_offside_map[p.op], p\n\n  _jsy_op(jsy_op, p) ::\n    if ! jsy_op ::\n      throw new Error @ `JSY op handler not found for \"${p.op}\"`\n\n    if jsy_op.warn :: jsy_op.warn(p)\n\n    if jsy_op.opResolve ::\n      jsy_op = validate_jsy_op_item @ jsy_op.opResolve(p)\n      if jsy_op.warn :: jsy_op.warn(p)\n\n    this._jsy_op_exec(jsy_op, p)\n\n  _jsy_op_exec(jsy_op, p) ::\n    if jsy_op.is_kw_close ::\n      this._dedent_nested_block(p)\n\n    this.stack_push @ jsy_op, p\n\n\n  _dedent_nested_block(p) ::\n    if ! this.head.in_nested_block :: return\n\n    if null != p ::\n      p.len_indent = this.head.nested_block_indent\n\n    let c = 0, done=false\n    while this.head && this.head.in_nested_block && ! done ::\n      done = this.head.op.in_nested_block\n      this.stack_pop @ c++\n\n  _dedent_multi_ops() ::\n    if ! this.head.loc :: return\n\n    const line = this.cur_ln.loc.start.line\n    const t = this.head.tail\n      .filter @ t => t.loc && line === t.loc.start.line\n      .pop()\n\n    if undefined === t :: return\n\n    let c = 0\n    while t !== this.head && !this.head.nestBreak ::\n      this.stack_pop @ c++\n\n  v$offside_dedent(p) ::\n    if ! p.ends_with_jsy_op ::\n      this._dedent_multi_ops()\n\n    let c = 0\n    while this.head.len_indent >= p.len_dedent ::\n      this.stack_pop @ c++\n\n\n  v$offside_indent(p) ::\n    this.emit_indent @ p.indent\n\n\n  v$template_param(p) :: this._param @ extra_jsy_ops.tmpl_param, p\n  v$template_param_end(p) :: this._param_end @ p\n\n  v$jsx_param(p) :: this._param @ extra_jsy_ops.jsx_param, p\n  v$jsx_param_end(p) :: this._param_end @ p\n\n  _param(op, p) ::\n    this.stack_push @ op, p\n    this.emit_raw @ p.content\n\n  _param_end(p) ::\n    this._dedent_nested_block(p)\n    this.emit_raw @ p.content\n\n    const comma_body = this.head.comma_body\n    if undefined !== comma_body ::\n      // fixup comma_body with simplified template param\n      comma_body.push @ 'null }'\n\n\n  v$str_template(p, ln, p0) ::\n    if p0 === ln.indent && p.block_indent ::\n      const indent = this._cur.pop()\n      this._cur.push @ indent.slice(p.block_indent)\n\n    this.emit @ p.content, p.loc.start\n\n  v$src(p, ln, p0) ::\n    let content = p.content\n    if {jsy_op:1, jsy_kw:1}[p0.type] && rx_leading_space.test(content) ::\n      content = content.replace(rx_leading_space, '')\n\n    this.emit @ content, p.loc.start\n\n\n  v$preprocessor(p, ln) ::\n    const preprocess = this.preprocess\n    const xform_cur = this.xform_tip\n    const add_xform = arg =>\n      this.push_xform(ln, xform_cur).update(arg)\n\n    const ans = preprocess @ p, add_xform\n\n    if p === ans ::\n      return this.emit @ p.content, p.loc.start\n    else if 'string' === typeof ans ::\n      return this.emit @ ans, p.loc.start\n    else if 'boolean' === typeof ans || 'function' === typeof ans ::\n      this.push_xform(ln, xform_cur).update(ans)\n\n    return this.emit_raw('')\n\n  preprocess(p) :: return p\n  push_xform(ln, xform_cur) ::\n    return this.xform_next = createTransform(ln, xform_cur)\n\n  _xform_start_line(ln) ::\n    while true ::\n      const xform = this.xform_tip\n      if undefined === xform :: return\n      if null !== ln && xform.depth <= ln.len_indent ::\n        return\n\n      this.xform_tip = xform.next\n      if xform.done :: xform.done(ln)\n\n  _xform_finish_line(line_src, ln) ::\n    const xform_tip = this.xform_tip\n\n    // switch to xform_next after finishing the current line\n    const xform_next = this.xform_next\n    if undefined !== xform_next ::\n      this.xform_next = undefined\n      this.xform_tip = xform_next\n\n    if undefined === xform_tip :: return line_src\n\n    return xform_tip.process(line_src, ln)\n\n\n  v$str: direct_src\n  v$str1: direct_src\n  v$str2: direct_src\n\n  v$regexp: direct_src\n\n  v$jsx_frag: direct_src\n  v$jsx_frag_close: direct_src\n  v$jsx_tag: direct_src\n  v$jsx_tag_part: direct_src\n  v$jsx_tag_close: direct_src\n  v$jsx_attr_name: direct_src\n  v$jsx_attr_str1: direct_src\n  v$jsx_attr_str2: direct_src\n  v$jsx_content: direct_src\n  v$jsx_content_expr: direct_src\n\n  v$hashbang: raw_src\n  v$comment_eol: raw_src\n  v$comment_multi: raw_src\n\n\nfunction raw_src(p) :: this.emit_raw @ p.content\nfunction direct_src(p) :: this.emit @ p.content, p.loc.start\n\nfunction validate_jsy_op_item(jsy_op_item) ::\n  const {pre, post} = jsy_op_item\n\n  if null !== pre && 'string' !== typeof pre ::\n    throw new Error @ 'Invalid resolved jsy_op_item.pre result'\n  if null !== post && 'string' !== typeof post ::\n    throw new Error @ 'Invalid resolved jsy_op_item.post result'\n\n  return jsy_op_item\n\nexport function sourcemap_comment(srcmap_json) ::\n  if 'string' !== typeof srcmap_json ::\n    srcmap_json = JSON.stringify(srcmap_json)\n\n  const b64 = 'undefined' !== typeof Buffer\n    ? Buffer.from(srcmap_json).toString('base64')\n    : window.btoa @ unescape @ encodeURIComponent @ srcmap_json\n\n  // break up the source mapping url trigger string to prevent false positives on the following line\n  return `//# ${'sourceMapping'}URL=data:application/json;charset=utf-8;base64,${b64}`\n\n"],"names":["at_lambda_offside"],"mappings":"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"}