{"version":3,"file":"rollup-jsy-bootstrap.mjs","sources":["../node_modules/tiny-source-map/esm/tiny-source-map.mjs","../code/jsy/utils.jsy","../code/jsy/jsy_lambda_operators.jsy","../code/jsy/jsy_func_operators.jsy","../code/jsy/jsy_prefix_operators.jsy","../code/jsy/jsy_operators.jsy","../code/jsy/regexp.jsy","../code/scanner/inject_dedent.jsy","../code/scanner/_location.jsy","../code/scanner/basic_offside.jsy","../code/scanner/context_scanner.jsy","../code/scanner/basic_contexts.jsy","../code/scanner/basic_offside_contexts.jsy","../code/scanner/scan_clike.jsy","../code/scanner/scan_javascript.jsy","../code/scanner/scan_jsx_javascript.jsy","../code/jsy/scan.jsy","../code/jsy/preprocess.jsy","../code/jsy/preprocess_visitor.jsy","../code/jsy/optional_comma.jsy","../code/jsy/jsy_visitor.jsy","../code/jsy/version.js","../code/jsy/transpile.jsy","../code/jsy/with_srcmap.jsy","../node_modules/picomatch/lib/constants.js","../node_modules/picomatch/lib/utils.js","../node_modules/picomatch/lib/scan.js","../node_modules/picomatch/lib/parse.js","../node_modules/picomatch/lib/picomatch.js","../node_modules/picomatch/index.js","../node_modules/@rollup/pluginutils/dist/es/index.js","../code/rollup.js"],"sourcesContent":["/* A tiny implementation of SourceMapGenerator usable in ES Module, CommonJS, and Browser friendly formats\n\nAPI:\n\n    {\n      addMapping({generated:{line, column}, original:{line, column}, source, name}) {},\n      setSourceContent(source, content) {},\n\n      toString() {},\n      toJSON() {},\n    }\n\nInspired and extracted from\n  require('source-map/lib/source-map-generator.js')\n\n*/\n\nfunction tiny_source_map_generator(src_map) {\n  src_map = {version: 3, ... (src_map || {}) };\n\n  const sources = [];\n  const names = [];\n  const mappings = [];\n  const contents = new Map();\n\n  return {\n    toJSON, toString: () => JSON.stringify(toJSON()),\n\n    setSourceContent(source, source_content) {\n      if (null != source_content)\n        contents.set(`${source}`, source_content);\n      else contents.delete(`${source}`);\n    },\n\n    addMapping({generated, original, source, name}) {\n      const m = {\n        gl: generated.line,\n        gc: generated.column,\n        ol: original != null && original.line,\n        oc: original != null && original.column, };\n\n      if (null != source) {\n        m.source = source = `${source}`;\n        if (! sources.includes(source))\n          sources.push(source);\n      }\n\n      if (null != name) {\n        m.name = name = `${name}`;\n        if (! names.includes(name))\n          names.push(name);\n      }\n\n      mappings.push(m);\n    },\n  }\n\n\n  function toJSON() {\n    const res_src_map = {\n      ... src_map,\n      sources: [... sources],\n      names: [... names]};\n\n    res_src_map.mappings =\n      _serializeMappings(\n        mappings, res_src_map);\n\n    if (0 !== contents.size)\n      res_src_map.sourcesContent =\n        res_src_map.sources.map(\n          key => contents.get(key) || null);\n\n    return res_src_map\n  }\n}\n\n\nfunction _serializeMappings(mappings, src_map) {\n  const vlq_gen_column = _vlq_state(0);\n  const vlq_orig_column = _vlq_state(0);\n  const vlq_orig_line = _vlq_state(0);\n  const vlq_name = _vlq_state(0);\n  const vlq_source = _vlq_state(0);\n\n  let line=1, result = '', prev_tip;\n  for (const tip of mappings) {\n    let sz = '';\n\n    if (tip.gl !== line) {\n      vlq_gen_column(0);\n      while (tip.gl !== line) {\n        sz += ';';\n        line++;\n      }\n    } else if (undefined !== prev_tip) {\n      if (0 === cmp_srcmappings(tip, prev_tip))\n        continue // if we didn't move forward, ignore it!\n\n      sz += ',';\n    }\n\n    sz += vlq_gen_column(tip.gc);\n\n    if (tip.source != null) {\n      sz += vlq_source(src_map.sources.indexOf(tip.source));\n      sz += vlq_orig_line(tip.ol - 1);\n      sz += vlq_orig_column(tip.oc);\n\n      if (tip.name != null) {\n        sz += vlq_name(src_map.names.indexOf(tip.name));\n      }\n    }\n\n    // success; move forward\n    result += sz;\n    prev_tip = tip;\n  }\n\n  return result\n}\n\nfunction _vlq_state(v0) {\n  const vlq = v => {\n    const res = _b64_vlq(v - v0);\n    vlq.value = v0 = v;\n    return res\n  };\n\n  vlq.value = v0;\n  return vlq\n}\n\n\nconst strcmp = (a, b) =>\n  a == b ? 0\n    : null == a ? 1\n    : null == b ? -1\n    : a > b ? 1 : -1;\n\nconst cmp_srcmappings = (a,b) => (\n     a.gl - b.gl\n  || a.gc - b.gc\n  || strcmp(a.source, b.source)\n  || a.ol - b.ol\n  || a.oc - b.oc\n  || strcmp(a.name, b.name) );\n\n\nconst _vlq_low = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef';\nconst _vlq_high = 'ghijklmnopqrstuvwxyz0123456789+/';\nfunction _b64_vlq(v) {\n  // move sign to LSB for VLQ encoding\n  v = v >= 0\n    ? (v << 1)\n    : 1 | ( -v << 1 );\n\n  let res = '';\n  while (true) {\n    // use lower 5 bits to generate a b64 symbol\n    let d = v & 0x1f;\n    v >>>= 5;\n    if (0 === v) {\n      res += _vlq_low[d];\n      return res\n    }\n\n    res += _vlq_high[d];\n  }\n}\n\nexport default tiny_source_map_generator;\n","\nconst rx_escape_offside_ops = /[?|+*@:.\\/\\\\\\(\\)\\{\\}\\[\\]\\=\\>]/g ;\nconst re_space_prefix = /(?:^|[ \\t]+)/.source ; // spaces or start of line\nconst re_space_suffix = /(?=$|[ \\t]+)/.source ; // spaces or end of line\n\nexport function regexp_from_jsy_op(jsy_op, with_spacing) ::\n  if 'string' === typeof jsy_op ::\n    // escape Offside operator chars to RegExp\n    jsy_op = jsy_op.replace @ rx_escape_offside_ops, '\\\\$&'\n    // surrounded by newlines or spacees\n    if with_spacing ::\n      jsy_op = re_space_prefix + jsy_op + re_space_suffix\n    return `(?:${jsy_op})` // using a non-matching group\n\n  if jsy_op instanceof RegExp ::\n    return jsy_op.source\n\n\nexport function sourcemap_comment(srcmap_json, newline='\\n') ::\n  if 'string' !== typeof srcmap_json ::\n    srcmap_json = JSON.stringify(srcmap_json)\n\n  let b64 = 'undefined' !== typeof Buffer\n    ? Buffer.from(srcmap_json).toString('base64')\n    : globalThis.btoa @ unescape @ encodeURIComponent @ srcmap_json\n\n  // break up the source mapping url trigger string to prevent false positives on the following line\n  return `${newline}//# ${'sourceMapping'}URL=data:application/json;charset=utf-8;base64,${b64}${newline}`\n\n\n","\n\n// @::   @::>   @::>*   @::*\nconst lambda_block_tbl = @{}\n  '': a => @: pre: `((${a}) => {`, post: '})'\n  '>': a => @: pre: `(async (${a}) => {`, post: '})'\n  '>*': a => @: pre: `((async function * (${a}) {`, post: '}).bind(this))'\n  '*': a => @: pre: `((function * (${a}) {`, post: '}).bind(this))'\n\n// @=>   @=>>\nconst lambda_arrow_tbl = @{}\n  __proto__: lambda_block_tbl\n  '': a => @: pre: `((${a}) =>`, post: ')'\n  '>': a => @: pre: `(async (${a}) =>`, post: ')'\n\n\n// @!::   @!::>   @!::>*   @!::*\nconst iife_expr_tbl = @{}\n  '': a => @: pre: `(((${a}) => {`, post: '})())'\n  '>': a => @: pre: `((async (${a}) => {`, post: '})())'\n  '>*': a => @: pre: `((async function * (${a}) {`, post: '}).call(this))'\n  '*': a => @: pre: `((function * (${a}) {`, post: '}).call(this))'\n\n\n// @!=>   @!=>>\nconst iife_arrow_tbl = @{}\n  __proto__: iife_expr_tbl\n  '': a => @: pre: `(((${a}) =>`, post: ')())'\n  '>': a => @: pre: `((async (${a}) =>`, post: ')())'\n\n\nconst bindLambdaOpZero = table =>\n  function opResolveLambdaZero(p) ::\n    let [_, suffix] = p.content.match(this.jsy_op)\n    let entry = table[suffix || '']\n    if undefined === entry ::\n      throw new SyntaxError @ `JSY lambda expression unrecognized specifier (\"${suffix}\")`\n    return entry('')\n\n\nconst fmt_arg_kw = args => `{${args}}`\nconst fmt_arg_vec = args => `[${args}]`\nconst bindLambdaOpResolve = (table, as_args=(v=>v)) =>\n  function opResolveLambda(p) ::\n    let [_, args, suffix] = p.content.match(this.jsy_op)\n    let entry = table[suffix || '']\n    if undefined === entry ::\n      throw new SyntaxError @ `JSY lambda with args expression unrecognized specifier (\"${suffix}\")`\n    return entry(as_args(args) || '')\n\n\n\nexport const at_lambda_offside = @[]\n  // object unpack all args\n  @{} jsy_op0: '@\\\\:=>', jsy_op: /@\\\\:(.*?)=>(>?\\*?)/,\n      pre: '(()=>', post: ')'\n      opResolve: bindLambdaOpResolve @ lambda_arrow_tbl, fmt_arg_kw\n  @{} jsy_op0: '@\\\\:::', jsy_op: /@\\\\:(.*?)::(>?\\*?)/,\n      pre: '(()=>{', post: '})',\n      opResolve: bindLambdaOpResolve @ lambda_block_tbl, fmt_arg_kw\n\n  // array unpack all args\n  @{} jsy_op0: '@\\\\#=>', jsy_op: /@\\\\#(.*?)=>(>?\\*?)/,\n      pre: '(()=>', post: ')'\n      opResolve: bindLambdaOpResolve @ lambda_arrow_tbl, fmt_arg_vec\n  @{} jsy_op0: '@\\\\#::', jsy_op: /@\\\\#(.*?)::(>?\\*?)/,\n      pre: '(()=>{', post: '})',\n      opResolve: bindLambdaOpResolve @ lambda_block_tbl, fmt_arg_vec\n\n  // normal args\n  @{} jsy_op0: '@\\\\=>', jsy_op: /@\\\\(.*?)=>(>?\\*?)/,\n      pre: '(()=>', post: ')'\n      opResolve: bindLambdaOpResolve @ lambda_arrow_tbl\n  @{} jsy_op0: '@\\\\::', jsy_op: /@\\\\(.*?)::(>?\\*?)/,\n      pre: '(()=>{', post: '})',\n      opResolve: bindLambdaOpResolve @ lambda_block_tbl\n\n  // zero args\n  @{} jsy_op0: '@=>', jsy_op: /@=>(>?\\*?)/,\n      pre: '(()=>', post: ')',\n      opResolve: bindLambdaOpZero @ lambda_arrow_tbl\n  @{} jsy_op0: '@::', jsy_op: /@::(>?\\*?)/,\n      pre: '(()=>{', post: '})',\n      opResolve: bindLambdaOpZero @ lambda_block_tbl\n\n\nexport const at_lambda_iife_offside = @[]\n  @{} jsy_op: '::!', pre: '{(()=>{', post: '})()}', is_kw_close: true\n  @{} jsy_op: '::!>', pre: '{(async ()=>{', post: '})()}', is_kw_close: true\n\n  @{} jsy_op0: '@!*>', jsy_op: /@!\\*>/, pre: '((async function *(){', post: '}).call(this))'\n  @{} jsy_op0: '@!*[]', jsy_op: /@!\\*\\[\\]/, pre: '[... (function *(){', post: '}).call(this)]'\n  @{} jsy_op0: '@!*#', jsy_op: /@!\\*#/, pre: '([... (function *(){', post: '}).call(this)])'\n  @{} jsy_op0: '@!*', jsy_op: /@!\\*/, pre: '((function *(){', post: '}).call(this))'\n\n  @{} jsy_op0: '@!=>', jsy_op: /@!=>(>?\\*?)/,\n      pre: '((()=>', post: ')())',\n      opResolve: bindLambdaOpZero @ iife_arrow_tbl\n\n  @{} jsy_op0: '@!::', jsy_op: /@!::(>?\\*?)/,\n      pre: '((()=>{', post: '})())',\n      opResolve: bindLambdaOpZero @ iife_expr_tbl\n\n  @{} jsy_op0: '@!', jsy_op: /@!(>?\\*?)(?!=>)/,\n      pre: '((()=>{', post: '})())',\n      opResolve: bindLambdaOpZero @ iife_expr_tbl\n\n\nexport const at_lambda_offside_all = [].concat @\n  at_lambda_offside\n  at_lambda_iife_offside\n\n\n","\n// Like lambdas without closing over `this`\n// @~::   @~::>   @~::>*   @~::*\nconst func_block_tbl = @{}\n  '': a => @: pre: `(function (${a}) {`, post: '})'\n  '>': a => @: pre: `(async function(${a}) {`, post: '})'\n  '>*': a => @: pre: `(async function * (${a}) {`, post: '})'\n  '*': a => @: pre: `(function * (${a}) {`, post: '})'\n\n\nexport const at_func_offside = @[]\n  @{} jsy_op0: '@~::', jsy_op: /@~(.*?)::(>?\\*?)/,\n      pre: '(function () {', post: '})',\n      opResolve(p) ::\n        let [_, args, suffix] = p.content.match(this.jsy_op)\n        let entry = func_block_tbl[suffix]\n        if undefined === entry ::\n          throw new SyntaxError @ `JSY function expression unrecognized specifier (\"${suffix}\")`\n        return entry(args || '')\n\n","import {regexp_from_jsy_op} from './utils.jsy'\n\n\nexport const as_op_prefix = (rx, sep=rx.source, inject_sep=sep) => @:\n  prefix: sep, rx_prefix: rx\n  opPrefixResolve(p, at_op) ::\n    let at_res = at_op.opResolve ? at_op.opResolve(p) : at_op\n    let pre = inject_sep + (at_res.pre || '')\n    return @{} ... at_res, pre\n\n\nexport const jsy_prefix_operators = @[]\n  as_op_prefix(/;/)\n  as_op_prefix(/,/)\n  as_op_prefix(/\\?(\\.?)/, '?', '?.')\n\n\nfunction * at_op_for_prefix(at_op, jsy_prefix_operators) ::\n  let {jsy_op0, jsy_op} = at_op\n  if ! /^[@?]/.test @ jsy_op0 || jsy_op ::\n    return\n\n  if undefined === jsy_op0 ::\n    jsy_op0 = jsy_op\n    jsy_op = new RegExp @ regexp_from_jsy_op(jsy_op, false)\n\n  else if 'string' === typeof jsy_op ::\n    jsy_op = new RegExp @ regexp_from_jsy_op(jsy_op, false)\n\n  else if 'function' !== typeof jsy_op.exec ::\n    throw new Error @ 'Unexpected jsy_op type'\n\n  for let jsy_prefix_op of jsy_prefix_operators ::\n    yield @{} ...at_op,\n      jsy_op0: jsy_prefix_op.prefix + jsy_op0\n      jsy_op: new RegExp @ `${jsy_prefix_op.rx_prefix.source}${jsy_op.source}`, jsy_op.flags\n      foldTop: true\n      opResolve: p => jsy_prefix_op.opPrefixResolve @ p, at_op\n\n\nexport function apply_prefix_operators(at_inner_operators, jsy_prefix_operators) ::\n  let res = []\n  for let at_op of at_inner_operators ::\n    res.push @ ... at_op_for_prefix(at_op, jsy_prefix_operators)\n  res.push(... at_inner_operators)\n  return res\n\n","import { at_lambda_offside, at_lambda_iife_offside } from './jsy_lambda_operators.jsy'\nimport { at_func_offside } from './jsy_func_operators.jsy'\nimport { apply_prefix_operators, jsy_prefix_operators } from './jsy_prefix_operators.jsy'\n\n// Order matters here -- list more specific matchers higher (first) in the order\nexport const at_outer_offside = @[]\n  @{} jsy_op: '::()', pre: '(', post: ')', nestBreak: true\n  @{} jsy_op: '::{}', pre: '{', post: '}', nestBreak: true\n  @{} jsy_op: '::[]', pre: '[', post: ']', nestBreak: true\n  @{} jsy_op: '::', pre: ' {', post: '}', nestBreak: true, is_kw_close: true\n\nexport const at_inner_offside_basic = @[]\n  @{} jsy_op: '@:', pre: '({', post: '})', implicitSep: ',', isFoldable: true\n  @{} jsy_op: '@#', pre: '([', post: '])', implicitSep: ',', isFoldable: true\n  @{} jsy_op: '@()', pre: '(', post: ')', implicitSep: ',', isFoldable: true\n  @{} jsy_op: '@{}', pre: '{', post: '}', implicitSep: ',', isFoldable: true\n  @{} jsy_op: '@[]', pre: '[', post: ']', implicitSep: ',', isFoldable: true\n  @{} jsy_op: '@', pre: '(', post: ')', implicitSep: ',', isFoldable: true\n\n\nexport const at_inner_offside_core = [].concat @\n  at_func_offside\n  at_lambda_offside\n  at_lambda_iife_offside\n  at_inner_offside_basic\n\n\nexport const at_experimental = @[]\n  /* experimental ideas; may be removed at any time */\n\n\nexport const at_unknown_ops = @[]\n  @{} jsy_op0: '?@', jsy_op: /\\?@[^\\w\\s]+/,\n  @{} jsy_op0: ';@', jsy_op: /;@[^\\w\\s]+/,\n  @{} jsy_op0: ',@', jsy_op: /,@[^\\w\\s]+/,\n  @{} jsy_op0: '::', jsy_op: /::[^\\w\\s]+/,\n  @{} jsy_op0: '@', jsy_op: /@[^\\w\\s]+/,\n\n\nexport const at_inner_offside = \n  apply_prefix_operators @\n    at_inner_offside_core.flat()\n    jsy_prefix_operators\n\n\nexport const op_template_str = @{} nestBreak: true\n\nexport const at_offside = [].concat @\n  at_outer_offside\n  at_inner_offside\n  at_experimental\n\n\nexport const at_offside_map = at_offside.reduce @\n  (m, ea) => ::\n    if ea.jsy_op0 ::\n      m[ea.jsy_op0] = ea\n\n    if 'string' === typeof ea.jsy_op ::\n      m[ea.jsy_op] = ea\n    return m\n  {}\n\n\nfunction kwExpandOp(p) ::\n  return @{} __proto__: this, pre: p.kw + this.pre\n\nexport const extra_jsy_ops = @{}\n  kw_normal: @{} jsy_op: 'kw', pre: ' (', post: ')', kwExpandOp, in_nested_block: true\n  kw_explicit: @{} jsy_op: 'kw', pre: '', post: '', kwExpandOp, in_nested_block: true\n  tmpl_param: @{} jsy_op: 'tmpl_param', pre: '', post: '', in_nested_block: true\n  jsx_param: @{} jsy_op: 'jsx_param', pre: '', post: '', in_nested_block: true\n\nexport const keywords_with_args = @[] 'if', 'while', 'for await', 'for', 'switch'\nexport const keywords_zero_args = @[] 'catch'\n\nexport const keywords_locator_parts = [].concat @\n  keywords_with_args.map @ e => `else ${e}`\n  keywords_with_args\n  keywords_zero_args\n","import { regexp_from_jsy_op } from './utils.jsy'\nimport { at_offside, at_unknown_ops, keywords_locator_parts } from './jsy_operators.jsy'\n\nconst regexp_keyword = sz => ::\n  sz = sz.replace(/[ ]+/g, '[ ]+') // allow one or more spaces\n  return `(?:${sz})` // using a non-matching group\n\nconst re_keyword_space_prefix = /^(?:[ \\t]*)/.source ; // start of line and indent\nconst re_keyword_trailer = /(?:[ \\t]*(?=[^\\w,:;=]|$))/.source ;\n\nexport const rx_keyword_ops = new RegExp @\n  re_keyword_space_prefix\n    + `(?:${keywords_locator_parts.map(regexp_keyword).join('|')})`\n    + re_keyword_trailer\n  , 'g' // global regexp for lastIndex support\n\nconst regexp_from_offside_op = offside_op =>\n  regexp_from_jsy_op @ offside_op.jsy_op, true\n\nexport const rx_offside_ops = new RegExp @\n  at_offside\n    .map(regexp_from_offside_op)\n    .filter(Boolean)\n    .join('|')\n  'g' // global regexp\n\nexport const rx_unknown_ops = new RegExp @\n  at_unknown_ops\n    .map(regexp_from_offside_op)\n    .filter(Boolean)\n    .join('|')\n  'g' // global regexp\n\n","\nexport function inject_dedent(offside_lines, trailing_types) ::\n  if 'function' !== typeof trailing_types ::\n    const s_trailing_types = new Set @\n      trailing_types || ['comment_eol']\n    trailing_types = k => s_trailing_types.has(k)\n\n  for const ln of offside_lines ::\n    if ln.is_blank :: continue\n\n    const {len_dedent, len_indent, len_inner} = ln\n\n    const offside_dedent = @{}\n      type: 'offside_dedent'\n      len_dedent, len_indent\n\n    if len_inner ::\n      offside_dedent.len_inner = len_inner\n\n    const last = ln.content.pop()\n    if last.multiline || trailing_types(last.type) ::\n      ln.content.push @ offside_dedent, last\n    else ::\n      ln.content.push @ last, offside_dedent\n\n","\nconst SourceLocation = @{}\n  __proto__: null\n\n  get [Symbol.toStringTag]() :: return '«SourceLocation»'\n  toString() :: return `«${this.line}:${this.column}»`\n  get column() :: return this.pos - this.line_pos\n\n  create(source, file) ::\n    const root = @{}\n      line:0, pos:0, line_pos:0\n      __proto__: SourceLocation\n\n    if null != file ::\n      root.file = file\n\n    Object.defineProperties @ root, @{}\n      __root__: @{} value: root\n      source: @{} value: source\n    return Object.freeze @ root\n\n  nextLine() ::\n    let {line, pos} = this\n    line += 1\n    return Object.freeze @:\n      line, pos, line_pos: pos,\n      __proto__: this.__root__\n\n  move(char_len) ::\n    if 'string' === typeof char_len ::\n      char_len = char_len.length\n    else if 'number' === typeof char_len ::\n      char_len |= 0\n    else throw new TypeError('Expected move to be a string or number')\n\n    let {line, pos, line_pos} = this\n    pos += char_len\n    return Object.freeze @:\n      line, pos, line_pos,\n      __proto__: this.__root__\n\n  distance(other) ::\n    const lines = this.line - other.line\n    const chars = this.pos - other.pos\n    return @{} lines, chars\n\n  slice(other) ::\n    if this.source !== other.source ::\n      throw new Error @ `Locations from different sources`\n    return this.source.slice @ this.pos, other.pos\n\n  syntaxError(message) ::\n    const err = new SyntaxError(message)\n    err.src_loc = this\n    return err\n\nexport default SourceLocation.create\n","export const rx_lines = /(\\r\\n|\\r|\\n)/ ;\nexport const rx_indent = /^([ \\t]*)(.*)$/ ;\nexport const rx_indent_order = /^[\\t]*[ ]*$/ ;\n\nimport createLoc from './_location.jsy'\n\nexport function basic_offside_scanner(source, feedback) ::\n  if null == feedback ::\n    feedback = @{}\n      warn(msg, ...args) :: console.warn @ `[Offside Warning]:: ${msg}`, ...args\n\n  const all_lines = []\n  const q_raw_lines = source.split(rx_lines)\n\n  const offside_line_proto = @{}\n    __proto__: null\n    get source() ::\n      const {start, end} = this.loc\n      return start.slice(end)\n\n  let loc_tip = createLoc(source, feedback.file)\n  let rx_indent_choice = null\n\n  while 0 !== q_raw_lines.length ::\n    const loc = @{} start: loc_tip = loc_tip.nextLine()\n\n    const src_line = q_raw_lines.shift() || ''\n    loc.end = loc_tip = loc_tip.move(src_line)\n\n    const src_line_end = q_raw_lines.shift() || ''\n    loc_tip = loc_tip.move(src_line_end)\n\n\n    const match = rx_indent.exec(src_line)\n    const loc_indent = loc.start.move(match[1])\n    const is_blank = 0 === match[2].length\n\n    if ! rx_indent_order.test(match[1]) ::\n      throw loc.start.syntaxError @ `Mixed tab and space indent (${loc_indent})`, \n\n    const raw = @{}\n      line: src_line\n      line_end: src_line_end\n      indent: match[1]\n      content: match[2]\n\n    let node\n    if is_blank ::\n      node = @{}\n        type: 'offside_blank_line', loc\n        is_blank\n\n    else ::\n      const indent_node = @{}\n        type: 'offside_indent',\n        loc: @{}\n          start: loc.start\n          end: loc_indent\n        len_indent: match[1].length\n        indent: match[1]\n\n      const conent_node = @{}\n        type: 'offside_content',\n        loc: @{}\n          start: loc_indent\n          end: loc.end\n        len_indent: match[1].length\n        indent: match[1]\n        content: match[2]\n\n      node = @{}\n        __proto__: offside_line_proto\n        type: 'offside_line', loc\n        indent: indent_node\n        content: conent_node\n        len_indent: match[1].length\n\n    Object.defineProperties @ node, @{} raw: {value: raw}\n    all_lines.push @ node\n\n  add_indent_info(all_lines)\n  return all_lines\n\n\nfunction add_indent_info(all_lines) ::\n  let len_dedent = 0 // how far to dedent to next outer level\n  let len_stack = [0]\n  // work backwards from the file end\n  for let i = all_lines.length-1 ; i>=0 ; i-- ::\n    let ln = all_lines[i]\n    if ln.is_blank :: continue\n\n    ln.len_dedent = len_dedent\n\n    // how many indent prefix chars per line\n    let len_indent = ln.len_indent\n\n    let len_inner\n    while len_stack[0] > len_indent ::\n      len_inner = len_stack.shift()\n\n    if len_stack[0] < len_indent ::\n      // len_indent is the new stack tip\n      len_stack.unshift @ len_indent\n\n    if len_inner ::\n      ln.len_inner = len_inner\n\n    len_dedent = len_indent\n","\nexport function ensure_indent(ctx, scanner) ::\n  const ln_first = scanner.ln_first\n  if undefined === ln_first :: return true\n  const len_first_indent = ln_first.len_indent\n\n  const d_dedent = ctx.ln.len_indent - len_first_indent\n  if d_dedent < 0 ::\n    throw ctx.ln.indent.loc.end.syntaxError @\n      `Invalid indent level in ${scanner.description}. (${ctx.ln.indent.loc.end})  --  current indent: ${ctx.ln.len_indent}  start indent: ${len_first_indent} from (${ln_first.loc.start})`\n  else return true\n\n\nexport function ensure_progress(loc0, loc1) ::\n  if loc0.pos == loc1.pos ::\n    throw new Error @ `Scanner failed to make progress (${loc1})`\n\n  if loc0.pos > loc1.pos ::\n    throw new Error @ `Scanner went backward (${loc1} from ${loc0})`\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class DispatchScanner ::\n  constructor(disp_name) ::\n    this.disp_name = disp_name || 'root'\n    this.by_kind = {}\n    this.by_op = {}\n\n  startCompile() ::\n    Object.defineProperties @ this, @{}\n      rx_list: @{} value: (this.rx_list || []).slice()\n    this.by_kind = Object.assign @ {}, this.by_kind\n    this.by_op = Object.assign @ {}, this.by_op\n    return this\n\n  addScannerList(scannerList) ::\n    for const scanner of scannerList ::\n      if scanner ::\n        this.addScanner(scanner)\n    return this\n\n  addScanner(scanner) ::\n    if scanner.withDispatch ::\n      scanner = scanner.withDispatch(this)\n\n    if scanner.is_body ::\n      this.ds_body = scanner\n\n    this.by_op[scanner.op] = scanner\n\n  addRegExpScanner(scanner, kind, re_disp) ::\n    if kind ::\n      this.by_kind[kind] = scanner.op\n      this.rx_list.push @ new RegExp(re_disp, 'g')\n    return this\n\n  finishCompile(ds_body) ::\n    if undefined === ds_body ::\n      ds_body = this.ds_body\n    return Object.defineProperties @ this, @{}\n      ds_body: @{} value: ds_body, writable: true\n\n\n  clone0() ::\n    if undefined !== this.level ::\n      throw new Error @ `Invalid clone0`\n    return this.cloneWithScanner()\n\n  cloneWithScanner(...scanners) ::\n    return this.cloneWithScannerList(scanners)\n  cloneWithScannerList(scanners) ::\n    const self = Object.create(this)\n    self.level = 1 + 0|self.level\n    self.description = self.description.replace @\n      /\\(\\d+\\)/, `(${self.level})`\n\n    self.startCompile()\n    self.addScannerList(scanners)\n    self.finishCompile()\n    return self\n\n\n  get_active_dispatch(ctx) ::\n    return ctx[`dispatch_${this.disp_name}`]\n  set_active_dispatch(ctx) ::\n    ctx.dispatch = ctx[`dispatch_${this.disp_name}`] = this\n\n\n  newline(ctx, is_blank) ::\n\n  scan(ctx, idx0) ::\n    const loc0 = ctx.loc_tip\n    const res = this._scan(ctx, idx0)\n    ensure_progress @ loc0, ctx.loc_tip\n    return res\n\n  _scan(ctx, idx0) ::\n    this.set_active_dispatch(ctx)\n\n    if undefined === this.ln_first ::\n      if undefined === this.level ::\n        throw new Error('Scanner with level: undefined')\n\n      this.ln_first = ctx.ln\n\n    ensure_indent(ctx, this)\n\n    const source = ctx.ln_source // slice is done by setting lastIndex\n    let match=null, idx1 = Infinity\n\n    for const rx of this.rx_list ::\n      rx.lastIndex = idx0 // regexp powered source.slice()\n\n      const m = rx.exec(source)\n      if null !== m && m.index < idx1 ::\n        idx1 = m.index\n        match = m\n\n    if null === match ::\n      return this.ds_body.scan(ctx, idx0)\n\n    if idx0 !== idx1 ::\n      return this.ds_body.scan_fragment @\n        ctx, source.slice(idx0, idx1)\n\n    const kind = match.filter(Boolean)[1]\n    const op = this.by_kind[kind]\n    const op_scanner = this.by_op[op]\n    if ! op_scanner ::\n      throw new Error @ `No scanner registered for « ${kind} »`\n\n    return op_scanner.scan(ctx, idx1)\n\n  scan_fragment(ctx, content) ::\n    throw new Error @ `${this.description} does not support fragments`\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class DispatchFirstlineScanner extends DispatchScanner ::\n  clone0() ::\n    const self = super.clone0()\n    self.ds_body = self.ds_body.clone0()\n    return self\n  scan(ctx, idx0) ::\n    ctx.scanner = this.ds_body\n    return super.scan(ctx, idx0)\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class EmbeddedDispatchScanner extends DispatchScanner ::\n  constructor(options) ::\n    super @ options.disp_name\n    Object.assign(this, options)\n    this._compileForInit()\n\n  _compileForInit() ::\n    this.startCompile()\n    this.addScannerList(this.scannerList)\n    this.finishCompile()\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class BaseSourceScanner ::\n  constructor(options) ::\n    Object.assign(this, options)\n    this._compileForInit()\n\n  _compileForInit() ::\n\n  withDispatch(ds) :: return this\n\n  emit_ast(ctx, content, ast_type) ::\n    const start = ctx.loc_tip\n    const end = ctx.loc_tip = start.move(content || 0)\n    const ast = @{} type: ast_type || this.op, loc: {start, end}, content\n    this.ast_extend(ctx, ast)\n    ctx.parts.push @ ast\n    return ast\n\n  ast_extend(ctx, ast) ::\n\n  newline(ctx, is_blank) ::\n  scan_fragment(ctx, content) ::\n    throw new Error @ `Scanner (${this.description}) does not support fragments`\n  scan(ctx, idx0) ::\n    throw new Error @ `Scanner (${this.description}) does not support scans`\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class SourceCodeScanner extends BaseSourceScanner ::\n  get is_body() :: return true\n\n  scan_fragment(ctx, content) ::\n    this.scan_content @ ctx, content\n\n  scan(ctx, idx0) ::\n    this.scan_content @ ctx, ctx.ln_source.slice(idx0)\n\n  scan_content(ctx, content) ::\n    if content ::\n      this.emit_ast @ ctx, content\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class NestedCodeScanner extends SourceCodeScanner ::\n  constructor(options) ::\n    super(options)\n    if ! this.char_pairs ::\n      throw new Error @ 'Missing required char_pairs mapping'\n\n    const chars = Object.keys(this.char_pairs).join('\\\\')\n    this.rx = new RegExp(`([${chars}])`)\n\n  withOuter(options) ::\n    const scanner = options.scanner\n    if 'function' !== typeof scanner.scan ::\n      throw new Error @ `Expected valid outer scanner`\n    delete options.scanner\n\n    const self = Object.create @ this, @{}\n      restore_scanner: @{} value: scanner\n    Object.assign @ self, options\n    return self\n\n  scan_content(ctx, nested_content) ::\n    const {stack, char_pairs} = this\n\n    let content = ''\n    for const tok of nested_content.split(this.rx) ::\n      const p = 1 === tok.length ? char_pairs[tok] : undefined\n\n      if undefined === p ::\n        content += tok\n        continue\n\n      if true === p ::\n        content += tok\n        stack.push @ tok\n        continue\n\n      const tip = stack.pop()\n      if tip !== p ::\n        const loc = ctx.loc_tip.move(content)\n        throw loc.syntaxError @\n          `Mismatched nesting in ${this.description} (${loc})`\n\n      if 0 !== stack.length ::\n        content += tok\n        continue\n\n      if content ::\n        this.emit_ast @ ctx, content\n      this.emit_ast @ ctx, tok, this.ast_end || 'nested_end'\n      ctx.scanner = this.restore_scanner\n      return\n\n    // all tokens with non-zero stack\n    if content ::\n      this.emit_ast @ ctx, content\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class RegExpScanner extends BaseSourceScanner ::\n\n  _compileForInit() ::\n    const {rx_open, rx_close} = this\n    const rx_disp = new RegExp @\n      (rx_open ? rx_open.source : '') + rx_close.source\n\n    const rx_resume = new RegExp @\n      '^' + rx_close.source\n\n    Object.defineProperties @ this, @{}\n      rx_disp: @{} value: rx_disp\n      rx_resume: @{} value: rx_resume\n\n  withDispatch(ds) ::\n    this.compileForDispatch(ds)\n    return this\n\n  compileForDispatch(ds) ::\n    if undefined === this.kind :: return\n\n    const match = this.rx_disp.exec @ this.example\n    if null === match || this.kind !== match[1] || null == match[2] ::\n      throw new Error @ `Invalid scanner regexp and/or example (${this.description})`\n\n    ds.addRegExpScanner @ this, this.kind, this.rx_disp.source\n\n\n\n  newline(ctx, is_blank) ::\n    if ! this.multiline && ! this.allow_blank_close ::\n      throw ctx.ln.loc.end.syntaxError @\n        `Newline in ${this.description} (${ctx.ln.loc.end})`\n\n  ast_extend(ctx, ast) ::\n    const ln = this.ln_first || ctx.ln\n    if undefined !== ln.len_inner ::\n      ast.block_indent = ln.len_inner\n    return ast\n\n  scan(ctx, idx0) ::\n    const match = this.rx_disp.exec @ ctx.ln_source.slice(idx0)\n    if null === match ::\n      throw ctx.loc_tip.syntaxError @\n        `Invalid scan ${this.description}. (${ctx.loc_tip})`\n\n    const [content, open, close] = match\n\n    const t_content = this.nestTrim(content, close, false)\n    if null != t_content ::\n      this.ast_scan_match @ {open, close},\n        this.emit_ast @ ctx, t_content,\n    return this.post_scan(ctx, close)\n\n  scan_continue(ctx, idx0) ::\n    ensure_indent(ctx, this)\n\n    const match = this.rx_resume.exec @ ctx.ln_source.slice(idx0)\n    if null === match ::\n      throw ctx.loc_tip.syntaxError @\n        `Invalid scan continue ${this.description}. (${ctx.loc_tip})`\n\n    const [content, close] = match\n\n    const t_content = this.nestTrim(content, close, true)\n    if null != t_content ::\n      this.ast_scan_match @ {close},\n        this.emit_ast @ ctx, t_content,\n    return this.post_scan(ctx, close)\n\n  ast_scan_match(match, ast) ::\n\n  nestTrim(content, close, isContinue) :: return content\n\n  post_scan(ctx, close) ::\n    if ! close ::\n      if this.invert_close ::\n        // e.g. no '\\' continuations at end of line\n        return true\n\n      if ! this.allow_blank_close ::\n        ctx.scanner = this.continueScanner(ctx)\n      return\n\n    else if this.invert_close ::\n      // e.g. '\\' continuations at end of line\n      ctx.scanner = this.continueScanner(ctx)\n\n    return this.nestMatch @ close,\n      ctx, this.hostScanner || this\n\n  nestMatch(close, ctx, hostScanner) ::\n    const nesting = this.nesting\n    if undefined !== nesting ::\n      return this.nestWith @\n        nesting[close],\n        ctx, hostScanner\n    return true // pop ctx.scanner\n\n  nestWith(nested, ctx, hostScanner) ::\n    if true === nested || undefined === nested || null === nested ::\n      return true // pop ctx.scanner\n\n    else if hostScanner === nested || 'host' === nested ::\n      ctx.scanner = hostScanner.continueScanner(ctx)\n      return\n\n    else if 'function' === typeof nested.nestedScanner ::\n      ctx.scanner = nested.nestedScanner(ctx)\n      return\n\n    else if 'function' === typeof nested ::\n      return nested @ ctx, hostScanner\n\n    return nested\n\n\n  nestedScanner(ctx) ::\n    return this._asNestedScanner @ ctx, 'nest', @{}\n\n  continueScanner(ctx) ::\n    return this._asNestedScanner @ ctx, 'cont', @{}\n      op: this.op_continue || this.op\n      continueScanner(ctx) :: return this\n      scan(ctx, idx0) ::\n        this.scan_continue(ctx, idx0)\n\n  _asNestedScanner(ctx, desc, body) ::\n    const restore_scanner = ctx.scanner\n    const self = @{}\n      __proto__: this\n      description: `${this.description} (${desc})`\n      ln_first: ctx.ln_first || ctx.ln\n\n      _pop_scanner(ctx) ::\n        if this.op_pop ::\n          this.emit_ast @ ctx, '', this.op_pop\n        ctx.scanner = restore_scanner\n\n      scan(ctx, idx0) ::\n        if true === super.scan(ctx, idx0) ::\n          this._pop_scanner(ctx)\n\n      scan_continue(ctx, idx0) ::\n        if true === super.scan_continue(ctx, idx0) ::\n          this._pop_scanner(ctx)\n\n    return Object.assign @ self, body\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class MultiLineScanner extends RegExpScanner ::\n  newline(ctx, is_blank) ::\n  get multiline() :: return true\n\n  ast_extend(ctx, ast) ::\n    //let ln = this.ln_first || ctx.ln\n    let col = ast.loc.start.column\n    let mlctx = this.mlctx ??= {col}\n\n    if col < mlctx.col ::\n      mlctx.col = col\n\n    ast.mlctx = mlctx\n    return ast\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class TaggedRegExpScanner extends RegExpScanner ::\n  withTag(ctx, tag, hostScanner) ::\n    const rx_replace = this.rx_replace || /tag/g\n\n    const re_open = this.rx_open.source\n      .replace @ rx_replace, tag\n    const re_close = this.rx_close.source\n      .replace @ rx_replace, tag\n\n    const rx_open = new RegExp @ re_open\n    const rx_close = new RegExp @ re_close\n    const rx_disp = new RegExp @ re_open + rx_close.source\n    const rx_resume = new RegExp @ '^' + re_close\n\n    const self = @{} __proto__: this, hostScanner,\n      rx_open, rx_close, rx_resume, rx_disp,\n      tag, ln_first: ctx.ln\n      compileForDispatch(ds) ::\n        // skip testing example for second pass of this object\n        ds.addRegExpScanner @ this, this.kind, this.rx_disp.source\n\n    self.tagScanner(ctx, tag, hostScanner)\n    return self\n\n  tagScanner(ctx, tag, hostScanner) ::\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class DynamicScanner extends MultiLineScanner ::\n  scan(ctx, idx0) ::\n    const leader_match = this.rx_disp.exec @ ctx.ln_source.slice(idx0)\n\n    const self = this.withLeaderTag @ ctx, leader_match[2]\n    return self._leader.scan(ctx, idx0)\n\n  withLeaderTag(ctx, tag) ::\n    const self = @{}\n      __proto__: this\n      __root__: this.__root__ || this\n      ln_first: ctx.ln\n\n    self._trailer = this.trailer && this.trailer.withTag @ ctx, tag, self\n    self._leader = this.leader.withTag @ ctx, tag, self\n    return self\n\n\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nexport class EmbeddedDynamicScanner extends DynamicScanner ::\n  continueScanner(ctx) ::\n    ensure_indent(ctx, this)\n    const ds_body = this.ds_body.cloneWithScanner @ this._trailer\n\n    // inherit ln_first\n    ds_body.ln_first = \n      ds_body.disp_name === ctx.dispatch.disp_name\n        ? ctx.dispatch.ln_first\n        : this.ln_first || ctx.ln\n\n    return ds_body\n\n  andDispatchWith(options) ::\n    options.scannerList = @[] ... options.scannerList, this\n    const ds_body = new EmbeddedDispatchScanner(options)\n    this.ds_body = ds_body\n    return ds_body\n\n","import { DispatchScanner, DispatchFirstlineScanner } from './context_scanner.jsy'\n\nexport function bind_context_scanner(context_scanners) ::\n  if ! Object.isFrozen(context_scanners) || ! Array.isArray(context_scanners) ::\n    throw new TypeError @ `Expected a frozen array of context scanners`\n\n  const cache = bind_context_scanner.cache || new WeakMap()\n  if cache !== bind_context_scanner.cache ::\n    bind_context_scanner.cache = cache\n\n  let res = cache.get(context_scanners)\n  if undefined === res ::\n    res = compile_context_scanner(context_scanners)\n    cache.set(context_scanners, res)\n  return res\n\n\nfunction compile_context_scanner(context_scanners) ::\n  const ds_first = build_composite_scanner(context_scanners)\n  return context_scanner\n\n  function context_scanner(offside_lines) ::\n    const ctx = @{} scanner: ds_first.clone0()\n\n    for const ln of offside_lines ::\n      if ln.is_blank ::\n        delete ln.content\n        ctx.scanner.newline(ctx, true)\n        continue\n\n\n      ctx.parts = []\n      ctx.ln = ln\n\n      scan_source(ctx, ln.content)\n\n      if 0 === ctx.parts.length ::\n        throw new Error @ `No parts generated by context scanner`\n\n      ln.content = ctx.parts\n      ctx.scanner.newline(ctx, false)\n\n    ctx.scanner.newline(ctx, true)\n    return offside_lines\n\n\n  function scan_source(ctx, ln_content) ::\n    const ln_source = ctx.ln_source = ln_content.content\n    const loc_start = ctx.loc_tip = ctx.loc_start = ln_content.loc.start\n    const pos0 = loc_start.pos\n\n    while true ::\n      const idx0 = ctx.loc_tip.pos - pos0\n      if idx0 >= ln_source.length ::\n        return // done with this line\n\n      ctx.scanner.scan @ ctx, idx0\n\n\n  function build_composite_scanner() ::\n    const ds_body = new DispatchScanner().startCompile()\n    ds_body.description = 'JSY Dispatch scanner (0)'\n    const ds_first = new DispatchFirstlineScanner().startCompile()\n    ds_first.description = 'Firstline JSY Dispatch scanner (0)'\n\n    for const scanner of context_scanners ::\n      if ! scanner :: continue\n\n      const ds = scanner.firstline ? ds_first : ds_body\n      ds.addScanner(scanner)\n\n    ds_body.finishCompile()\n    return ds_first.finishCompile(ds_body)\n\n","import { basic_offside_scanner } from './basic_offside.jsy'\nimport { bind_context_scanner } from './basic_contexts.jsy'\n\nexport function scan_offside_contexts(source, feedback, disp_name, context_scanners) ::\n  // see scan_javascript and scan_clike for good context_scanners\n  const context_scanner = bind_context_scanner(disp_name, context_scanners)\n  return context_scanner @ basic_offside_scanner(source, feedback)\n\n","import { SourceCodeScanner, NestedCodeScanner, RegExpScanner, MultiLineScanner } from './context_scanner.jsy'\nimport { scan_offside_contexts } from './basic_offside_contexts.jsy'\n\nexport const scanner_source =\n  new SourceCodeScanner @:\n      description: 'Source Code Scanner'\n      op: 'src'\n\nexport const scanner_nestedSrc =\n  new NestedCodeScanner @:\n    op: 'src', description: 'Template parameter source'\n    char_pairs: @{}\n      '{': true, '}': '{'\n      '(': true, ')': '('\n      '[': true, ']': '['\n\nexport const scanner_hashbangDirective =\n  new RegExpScanner @:\n      description: 'Hashbang directive'\n      example: '#!/usr/bin/env node'\n      op: 'hashbang', kind:'#!'\n      rx_open: /^(#!)/, rx_close: /.*($)/,\n      firstline: true\n      allow_blank_close: true\n\nexport const scanner_commentEOL =\n  new RegExpScanner @:\n      description: 'Comment to end of line'\n      example: '// comment'\n      op: 'comment_eol', kind:'//'\n      rx_open: /(\\/\\/)/, rx_close: /.*($)/,\n      allow_blank_close: true\n\nexport const scanner_commentMultiLine =\n  new MultiLineScanner @:\n      description: 'Multi-line comment'\n      example: '/* comment */'\n      op: 'comment_multi', kind:'/*'\n      rx_open: /(\\/\\*)/, rx_close: /.*?(\\*\\/|$)/,\n\nexport const scanner_strSingle =\n  new RegExpScanner @:\n      description: 'Single quote string literal'\n      example: \"'single quote'\"\n      op: 'str1', kind:\"'\"\n      rx_open: /(')/, rx_close: /(?:\\\\.|[^'])*('|$)/,\n\nexport const scanner_strDouble =\n  new RegExpScanner @:\n      description: 'Double quote string literal'\n      example: '\"double quote\"'\n      op: 'str2', kind:'\"'\n      rx_open: /(\")/, rx_close: /(?:\\\\.|[^\"])*(\"|$)/,\n\nexport const scanner_preprocessor =\n  new RegExpScanner @:\n      description: 'Preprocessor directive'\n      example: '# IF platform === \"web\"'\n      op: 'preprocessor', kind:'#'\n      rx_open: /^\\s*(#)/, rx_close: /.*?([\\\\]?)\\s*$/,\n      invert_close: true // preprocessor uses '\\' continuations\n      allow_blank_close: true\n\n\nexport const clike_context_scanners = Object.freeze @#\n  scanner_source\n  scanner_hashbangDirective\n  scanner_commentEOL\n  scanner_commentMultiLine\n  scanner_strSingle\n  scanner_strDouble\n  scanner_preprocessor\n\n\nexport function scan_clike(source, feedback) ::\n  return scan_offside_contexts(source, feedback, clike_context_scanners)\n\n","import { scan_offside_contexts } from './basic_offside_contexts.jsy'\nimport { RegExpScanner, MultiLineScanner } from './context_scanner.jsy'\nimport { scanner_source, clike_context_scanners, scanner_nestedSrc } from './scan_clike.jsy'\n\nexport const scanner_regexp =\n  new RegExpScanner @:\n      description: 'RegExp literal'\n      example: '/regexp/'\n      op: 'regexp'\n      kind: '/'\n\n      /*\n      rx_open: rx_or_parts @:\n        opts: @[]\n          /(\\/)(?![\\/\\*])/    // start of a potential regexp literal, but not a comment\n\n          @{}                 // ...complex regexp grammar...\n            pre: ''\n            opts: @[]\n              /\\\\./           // ...any escaped character...\n              /[^\\\\\\/\\[]/     // ...or any non-special character...\n\n              @{}             // ... or a bracket [] expression...\n                pre: '\\\\['        // started with a '[' character\n                opts: @[]\n                  /\\\\./           // ...with any escaped character\n                  /[^\\]]/         // ...or any non-escaped non-ending ']' character\n                post: '*\\\\]'      // ended with an ending ']' character\n\n            post: '+'         // one or more interior expressions\n\n          /(?=\\/)/            // (lookahead) end of a regexp literal\n      */\n\n      rx_open: new RegExp @\n        /(\\/)(?![\\/\\*])/ .source + // a RegExp start but not a comment\n        /(?:\\\\.|[^\\\\\\/\\[]|\\[(?:\\\\.|[^\\]])*\\])+/ .source\n\n      rx_close: /(\\/[a-z]*)\\s*(?=[;.,)\\]}]|$)/  // inspired by vim's syntax highlighting end\n\n      //multiline: false // spec https://tc39.es/ecma262/#sec-literals-regular-expression-literals\n\n\nexport const scanner_strTemplate =\n  new MultiLineScanner @:\n      description: 'Template quote string literal'\n      example: '`template string`'\n      op: 'str_template'\n      kind: '`'\n      rx_open: /(`)\\\\?/\n      rx_close: /(?:\\\\.|\\$(?!{)|[^\\$`\\\\])*(`|\\${|$)/\n      nesting: @{}\n        '${': templateArgNesting\n\n      ast_scan_match(scan, ast) ::\n        if '`' == scan.open ::\n          ast.tmpl_opened = true\n        if '`' == scan.close ::\n          ast.tmpl_closed = true\n\nfunction templateArgNesting(ctx, hostScanner) ::\n  const src = scanner_nestedSrc.withOuter @:\n    scanner: hostScanner.continueScanner(ctx)\n    stack: @[] '{' // from the template parameter opening\n    ast_end: 'template_param_end'\n\n  src.emit_ast @ ctx, '', 'template_param'\n\n  ctx.scanner = ctx.dispatch_root.cloneWithScanner(src)\n\n\n\nexport const js_context_scanners = Object.freeze @#\n  scanner_regexp\n  scanner_strTemplate\n  ... clike_context_scanners\n\nexport function scan_javascript(source, feedback) ::\n  return scan_offside_contexts(source, feedback, js_context_scanners)\n\n","import { scan_offside_contexts } from './basic_offside_contexts.jsy'\nimport { js_context_scanners } from './scan_javascript.jsy'\nimport { scanner_nestedSrc } from './scan_clike.jsy'\nimport { SourceCodeScanner, RegExpScanner } from './context_scanner.jsy'\nimport { EmbeddedDynamicScanner, TaggedRegExpScanner } from './context_scanner.jsy'\n\n\nexport const scanner_jsxContent =\n  new SourceCodeScanner @:\n      description: 'JSX Content Scanner'\n      op: 'jsx_content'\n\nexport const scanner_jsxContentExpr =\n  new RegExpScanner @:\n      description: 'JSX Content Expression'\n      example: '{ param }'\n      op: 'jsx_content_expr'\n      kind: '{'\n      rx_open: /\\s*({)/,\n      rx_close: /()/,\n\n      nestTrim(content, close, isContinue) ::\n      post_scan(ctx) :: jsxArgNesting @ ctx, null\n\nexport const scanner_jsxAttrNameValue =\n  new RegExpScanner @:\n      description: 'JSX attribute name value'\n      op: 'jsx_attr_name'\n      rx_open: /\\s*([a-zA-Z0-9_:.\\-]+)/,\n      rx_close: /\\s*(=)\\s*/,\n\nexport const scanner_jsxAttrNameOnly =\n  new RegExpScanner @:\n      description: 'JSX attribute name only'\n      op: 'jsx_attr_name_only'\n      rx_open: /\\s*([a-zA-Z0-9_:.\\-]+)/,\n      rx_close: /()/,\n\n      post_scan(ctx, close) ::\n        return this.nestMatch @ close,\n          ctx, this.hostScanner || this\n\nexport const scanner_jsxAttrSingle =\n  new RegExpScanner @:\n      description: 'JSX Single quote attribute literal'\n      multiline: true\n      op: 'jsx_attr_str1'\n      rx_open: /\\s*(')/,\n      rx_close: /(?:\\\\.|[^'])*(')\\s*/,\n\nexport const scanner_jsxAttrDouble =\n  new RegExpScanner @:\n      description: 'JSX Double quote attribute literal'\n      multiline: true\n      op: 'jsx_attr_str2'\n      rx_open: /\\s*(\")/,\n      rx_close: /(?:\\\\.|[^\"])*(\")\\s*/,\n\nexport const scanner_jsxTagClose =\n  new TaggedRegExpScanner @:\n      description: 'JSX Close Tag'\n      example: '</tag>'\n      op: 'jsx_tag_close'\n      kind: '</'\n      multiline: true\n      rx_open: /(<\\/)\\s*/\n      rx_close: /([a-zA-Z0-9_:.\\-]+)\\s*>/\n\n      tagScanner(ctx) ::\n        this.restore_scanner = ctx.scanner\n\n      post_scan(ctx, close) ::\n        if close !== this.tag ::\n          throw ctx.loc_tip.syntaxError @\n            `Mismatched JSX close tag \"</${close}>\", expected \"</${this.tag}>\". (${ctx.loc_tip})`\n\n        ctx.scanner = this.restore_scanner\n\n\n\nexport const scanner_jsxTag =\n  new TaggedRegExpScanner @:\n      description: 'JSX Tag'\n      multiline: true\n      op: 'jsx_tag'\n      op_continue: 'jsx_tag_part'\n\n      rx_open: /(<)tag\\b\\s*/\n      rx_close: /\\s*?($|\\/>|[{'\">]|[a-zA-Z0-9_:.\\-]+=?)/\n\n      nesting: @{}\n        '>': 'host' // use hostScanner\n        '/>': true // pop ctx.scanner\n\n      nestingEnd: @{}\n        '{': jsxArgNesting\n        '=': scanner_jsxAttrNameValue\n        \"'\": scanner_jsxAttrSingle\n        '\"': scanner_jsxAttrDouble\n\n      nestTrim(content, close, isContinue) ::\n        if ! this.nesting[close] ::\n          content = content.slice(0, - close.length)\n        return content || null\n\n      nestMatch(close, ctx, hostScanner) ::\n        let inner = this.nesting[close]\n        if undefined === inner ::\n          inner = this.nestingEnd[close.slice(-1)]\n            || scanner_jsxAttrNameOnly\n\n        if true !== inner && 'host' !== inner ::\n          // we're actually pushign two scanners onto the stack\n          // the first for this context, the second for the attribute\n          ctx.scanner = hostScanner = this.continueScanner(ctx)\n\n        return this.nestWith @ inner, ctx, hostScanner\n\nfunction jsxArgNesting(ctx, hostScanner) ::\n  const src = scanner_nestedSrc.withOuter @:\n    scanner: null !== hostScanner\n      ? hostScanner.continueScanner(ctx)\n      : ctx.scanner\n    stack: @[] '{' // from the jsx parameter opening\n    ast_end: 'jsx_param_end'\n\n  src.emit_ast @ ctx, '{', 'jsx_param'\n\n  ctx.scanner = ctx.dispatch_root.cloneWithScanner(src)\n\n\n\n\nexport const scanner_jsx =\n  new EmbeddedDynamicScanner @:\n      description: 'Embedded JSX expression'\n      example: '<section>content</section>'\n      kind:'<'\n      disp_name: 'jsx'\n      op: 'jsx'\n\n      // recognize by '<tag' followed by 'attr=' or '/>' or '>'\n      rx_open: /(<)([a-zA-Z0-9_:.\\-]+)(?=\\s*?(?:$|\\/>|>|\\s{|\\s[a-zA-Z0-9_:\\-]+=?))/\n      rx_close: /.*$/\n\n      leader: scanner_jsxTag\n      trailer: scanner_jsxTagClose\n\n\nexport const scanner_embedded_jsx =\n  scanner_jsx.andDispatchWith @:\n    description: 'JSX Dispatch Scanner (0)'\n    disp_name: 'jsx'\n\n    scannerList: @[]\n      scanner_jsxContent\n      scanner_jsxContentExpr\n\nexport const scanner_jsx_close_fragment =\n  new RegExpScanner @:\n      description: 'Embedded JSX fragment close expression'\n      example: '</>'\n      op: 'jsx_frag_close'\n      kind: '</'\n      allow_blank_close: true\n\n      rx_open: /(<\\/)\\s*/\n      rx_close: /([a-zA-Z0-9_:.\\-]*)\\s*>/\n\n      post_scan(ctx, close) ::\n        if close ::\n          throw ctx.loc_tip.syntaxError @\n            `Mismatched JSX fragment close tag \"</${close}>\", expected \"</$>\". (${ctx.loc_tip})`\n\n        ctx.scanner = this.restore_scanner\n\nexport const scanner_jsx_fragment =\n  new RegExpScanner @:\n      description: 'Embedded JSX fragment expression'\n      example: '<></>'\n      op: 'jsx_frag'\n      kind: '<>'\n\n      rx_open: /(<>)/\n      rx_close: /.*($|<\\/>)/\n\n      nestTrim(content, close, isContinue) ::\n        return '<>'\n\n      post_scan(ctx) ::\n        const jsx_frag_close = @{}\n          __proto__: scanner_jsx_close_fragment\n          restore_scanner: ctx.scanner\n\n        const ds_body = \n          scanner_embedded_jsx.cloneWithScanner @\n            jsx_frag_close\n\n        ds_body.description = 'Fragment' + ds_body.description\n        const disp = ds_body.get_active_dispatch(ctx)\n        ds_body.ln_first = disp && disp.ln_first || ctx.ln\n\n        ctx.scanner = ds_body\n\n\n\n\nexport const jsx_context_scanners = Object.freeze @#\n  scanner_jsx_fragment\n  scanner_jsx\n  ... js_context_scanners\n\nexport function scan_javascript_with_jsx(source, feedback) ::\n  return scan_offside_contexts(source, feedback, jsx_context_scanners)\n\n\n","import { rx_offside_ops, rx_keyword_ops, rx_unknown_ops } from './regexp.jsy'\nimport { inject_dedent } from '../scanner/inject_dedent.jsy'\nimport { scan_javascript_with_jsx } from '../scanner/scan_jsx_javascript.jsy'\n\nexport * from '../scanner/ast_debug.jsy'\n\nconst _is_offside_dedent = part => 'offside_dedent' === part.type\nexport function jsy_scan(source, feedback) ::\n  const jsy_ast = scan_javascript_with_jsx(source, feedback)\n\n  inject_dedent @ jsy_ast, @[] 'comment_eol'\n\n  for let ln of jsy_ast ::\n    if ln.is_blank :: continue\n\n    let ln_parts = ln.content = transform_jsy_ops(ln.content, ln)\n\n    let idx_tail = ln_parts.findIndex @ _is_offside_dedent\n    let dedent = ln_parts[idx_tail--]\n\n    while idx_tail >= 0 ::\n      let tail = ln_parts[idx_tail--]\n      if undefined === tail ::\n        continue\n\n      if /^jsy_op/.test(tail.type) ::\n        dedent.ends_with_jsy_op = true\n        tail.ending_jsy_op = true\n      else if 'src' !== tail.type || tail.content.trim() ::\n        break\n\n  return jsy_ast\n\n\n\nfunction transform_jsy_ops(ln_parts, ln) ::\n  const res = []\n\n  for let p, i=0; undefined !== (p = ln_parts[i]) ; i++ ::\n    if 'src' === p.type ::\n      transform_jsy_part(res, p, ln)\n    else res.push(p)\n\n\n  // allow keywords at the start and in code blocks after \"::\"\n  let kw_allowed = 'src' === res[0].type\n  for let idx=0 ; undefined !== res[idx] ; idx ++ ::\n    if kw_allowed ::\n      transform_jsy_keyword(res, idx, ln)\n      kw_allowed = false\n\n    else if 'jsy_op' === res[idx].type ::\n      kw_allowed = '::' === res[idx].op\n\n  return res\n\n\n\nfunction transform_jsy_keyword(res, idx, ln) ::\n  const first = res[idx]\n\n  rx_keyword_ops.lastIndex = 0\n  const kw_match = rx_keyword_ops.exec(first.content)\n  if ! kw_match :: return false\n\n  const rest = kw_match.input.slice @ rx_keyword_ops.lastIndex\n  if '(' === rest[0] ::\n    return res // explicit keyword arguments\n\n  const kw_start = first.loc.start\n  const kw_end = kw_start.move @ kw_match[0]\n  const kw = kw_match[0].split(' ').filter(Boolean).join(' ')\n\n  const after = rest ? null : res[1+idx]\n  const explicit = after && 'jsy_op' === after.type && '@' === after.op\n\n  const kw_node = @{}\n    type: 'jsy_kw', kw, \n    loc: @{} start: kw_start, end: kw_end\n    len_indent: ln.len_indent\n    explicit\n\n  const post_node = as_src_ast @ rest, kw_end, first.loc.end\n\n  res.splice @ idx, 1, kw_node, post_node\n  return true\n\n\nfunction transform_jsy_part(res, part, ln) ::\n  ::\n    rx_offside_ops.lastIndex = 0\n\n    let loc_tip = part.loc.start\n    while true ::\n      let start = loc_tip, idx0 = rx_offside_ops.lastIndex\n      const op_match = rx_offside_ops.exec(part.content)\n\n      if ! op_match ::\n        _tail(loc_tip, idx0)\n        return res\n\n      if idx0 < op_match.index ::\n        start = loc_tip = _inner(loc_tip, idx0, op_match.index)\n        idx0 = rx_offside_ops.lastIndex\n\n\n      const op = op_match[0].trim()\n      const end = loc_tip = loc_tip.move(op_match[0])\n\n      const op_part = @{}\n        type: 'jsy_op', op\n        loc: @{} start, end\n        len_indent: ln.len_indent\n        content: op_match[0]\n\n      const op_args = op_match.slice(1).filter(Boolean)\n      if op_args.length ::\n        op_part.type = 'jsy_op_args'\n        op_part.op_args = op_args\n        op_part.op = op_args.reduce @\n          (op, p) => op.replace(p, ''), op\n\n      res.push @ op_part\n\n  function _unknown_ops(content, loc_tip, idx0) ::\n    rx_unknown_ops.lastIndex = idx0\n    const op_unknown = rx_unknown_ops.exec(content)\n    if op_unknown ::\n      const op = op_unknown[0].trim()\n      const start = loc_tip\n      const end = loc_tip = loc_tip.move(op_unknown[0])\n      res.push @:\n        type: 'jsy_unknown', op\n        loc: @{} start, end\n        len_indent: ln.len_indent\n        content: op_unknown[0]\n\n  function _inner(loc_tip, idx0, idx_content) ::\n    const pre = part.content.slice(idx0, idx_content)\n    _unknown_ops(pre, loc_tip, idx0)\n\n    const start = loc_tip\n    const end = loc_tip.move(pre)\n    res.push @ as_src_ast @ pre, start, end\n    return end\n\n  function _tail(loc_tip, idx0) ::\n    const rest = part.content.slice(idx0)\n    if rest ::\n      _unknown_ops(rest, loc_tip, idx0)\n\n      const start = loc_tip\n      const end = start.move(rest)\n      res.push @ as_src_ast @ rest, start, end\n\nfunction as_src_ast(content, start, end) ::\n  return @{} type: 'src', loc: {start, end}, content\n\n\nexport { jsy_scan as scan_jsy, jsy_scan as default }\n","\nconst pp_sym = Symbol('#IF?')\nconst basic_preprocessor_proto = @{}\n  bind() ::\n    const rx = /^#\\s*([A-Z]+\\b)(.*)$/\n    return @\\ part, stacktop ::\n      let [,directive,arg] = rx.exec(part.content) || []\n      if ! this['v$'+directive] ::\n        throw this.syntaxError(part)\n\n      return this['v$'+directive] @\n        part, (arg||'').trim(), stacktop\n\n  syntaxError: part => part.loc.start.syntaxError @ `Preprocessor Invalid: \"${part.content}\"`\n\n  v$IF(part, arg, stacktop) ::\n    if ! arg :: throw this.syntaxError(part)\n    let ans = !! this.answerFor(arg)\n    return stacktop[pp_sym] = ans\n\n  v$ELIF(part, arg, stacktop) ::\n    if ! arg || 'boolean' !== typeof stacktop[pp_sym] ::\n      throw this.syntaxError(part)\n\n    if ! stacktop[pp_sym] ::\n      let ans = !! this.answerFor(arg)\n      return stacktop[pp_sym] = ans\n    return false\n\n  v$ELSE(part, arg, stacktop) ::\n    if arg || 'boolean' !== typeof stacktop[pp_sym] ::\n      throw this.syntaxError(part)\n\n    if ! stacktop[pp_sym] ::\n      stacktop[pp_sym] = null\n      return true\n    return false\n\n\nexport function basic_preprocessor(answerFor) ::\n  if null == answerFor ::\n    return // defines is null -- disable preprocessor\n\n  if 'object' === typeof answerFor ::\n    answerFor = shunting_yard(answerFor)\n  else if 'function' !== typeof answerFor ::\n    throw new TypeError @ `Expected a function or object for basic_preprocessor`\n\n  return {__proto__: basic_preprocessor_proto, answerFor}.bind()\n\n\nexport function shunting_yard(defines) ::\n  ::\n    let _op_ = (order, op_fn) => (op_fn.order=order, op_fn)\n    let NOT = v => ! v\n    let AND = (a, b) => a && b\n    let OR = (a, b) => a || b\n\n    let ops = @{}\n      __proto__: null\n      false: false, FALSE: false,\n      true: true, TRUE: true\n      NOT, '!': _op_(0, NOT),\n      AND, '&&': _op_(10, AND),\n      OR, '||': _op_(20, OR),\n\n    var lut_expr = key => ops[key] ?? defines[key]\n\n  function eval_op(fn_op, args) ::\n    args.push @\n      fn_op.length\n        ? fn_op(... args.splice(-fn_op.length))\n        : fn_op()\n\n  return function eval_shunting_yard(expr_src) ::\n    // see https://en.wikipedia.org/wiki/Shunting-yard_algorithm\n    let args=[], ops=[]\n\n    let expr = expr_src.split(/\\s+/).map(lut_expr)\n    for let tip of expr ::\n      if 'function' !== typeof tip ::\n        args.push(tip)\n        continue\n\n      // eval all lesser order operations\n      while ops[0] && (0 | ops[0].order) <= (0 | tip.order) ::\n        eval_op(ops.shift(), args)\n\n      // push this operator on the stack\n      ops.unshift(tip)\n\n    // evaluate all operations\n    while ops[0] ::\n      eval_op(ops.shift(), args)\n\n    if 1 !== args.length ::\n      throw new SyntaxError @\n        `Invalid preprocessor expression: \"${expr_src}\"`\n\n    return args[0]\n\n","\nexport const preprocess_visitor = @{}\n  __proto__: null\n\n  *ast_iter(ast) ::\n    let ln, state = this.start()\n\n    for ln of ast ::\n      ln = ln.is_blank\n        ? this.blank_line(ln)\n        : this.ast_line(ln, state)\n\n      if null != ln ::\n        yield ln\n\n    ln = this.finish(state)\n    if null != ln ::\n      yield ln\n\n  start() :: return @{} tip: {}\n  finish(state) ::\n\n  blank_line(ln) :: return ln\n\n  indent_state(ln, state) ::\n    let tip = state.tip\n    while ln.len_indent < (tip.len|0) ::\n      tip = tip.tail\n\n    return state.tip = tip\n\n  _dbg_ln(ln) :: return ln.indent.indent + ln.content.map(v=>v.content||'').join('')\n\n  ast_line(ln, state) ::\n    let tip = this.indent_state(ln, state)\n\n    if 'exclude' === tip.op ::\n      this.exclude_line(ln, state)\n      return ln\n\n    //if tip.dedent > 0  ::\n    //  ln.indent.indent = ln.indent.indent.slice(0, -tip.dedent)\n\n    for let part of ln.content ::\n      this[`v$${part.type}`]?.( part, ln, state )\n    return ln\n\n  preprocess(p, stacktop) ::\n  v$preprocessor(p, ln, state) ::\n    let tail = state.tip\n    let ans = p.ans = this.preprocess(p, tail)\n\n    if false === ans ::\n      p.type += '_exc'\n      state.tip = @{}\n        op: 'exclude'\n        len: ln.len_inner\n        tail\n\n    else if true === ans ::\n      p.type += '_inc'\n      state.tip = @{}\n        len: ln.len_inner\n        //dedent: (tail.dedent|0) + ln.len_inner - ln.len_indent\n        tail\n\n    else if 'string' === typeof ans ::\n      p.type += '_sz'\n\n\n  exclude_line(ln, state) ::\n    let content = @[]\n      @{} type: 'exclude_line', content: '//~ '\n\n    for let part of ln.content ::\n      if 'offside_dedent' === part.type ::\n        content.unshift(part)\n      else ::\n        part.type = 'exclude_part'\n        content.push(part)\n\n    ln.content = content\n    return ln\n\n","const rx_punct = /[,.;:?]/\nconst rx_binary_ops = /\\&\\&|\\|\\||\\?\\?/\nconst rx_add_sub_ops = /(?<![+-])[+-]/ // but exclude increment and decrement ops\n\nconst rx_disrupt_comma_tail = \n  _regexp_join('', [ rx_punct, /=>/, rx_add_sub_ops, rx_binary_ops ], '\\\\s*$')\n\nconst rx_disrupt_comma_head = \n  _regexp_join('^\\\\s*', [ rx_punct, rx_binary_ops ], '')\n\nconst rx_rescue_comma_head = \n  _regexp_join('^\\\\s*', [ /\\.\\.\\./ ], '')\n\nconst rx_last_bits = /[()\\[\\]{}]|<\\/?\\w*>/ ;\nconst rx_dict_as_name = /\\s+as\\s+\\w+/g\n\nexport function checkOptionalComma(op, pre_body, post_body) ::\n  let pre_end = pre_body.split(rx_last_bits).pop()\n  if rx_disrupt_comma_tail.test(pre_end) ::\n    return false\n\n  let post_start = post_body.split(rx_last_bits).shift()\n  if rx_disrupt_comma_head.test(post_start) ::\n    if ! rx_rescue_comma_head.test(post_start) ::\n      return false\n\n  if op.pre.includes('{') ::\n    // support for blocks like:\n    //   import {name as othername} from 'file' blocks\n    //   export {name as othername}\n    pre_body = pre_body.replace(rx_dict_as_name, '')\n    post_body = post_body.replace(rx_dict_as_name, '')\n\n  if checkSyntax @ `${op.pre} ${pre_body} , post_body ${op.post}` ::\n    return true\n\n  if checkSyntax @ `${op.pre} pre_body , ${post_body} ${op.post}` ::\n    return true\n\n  return false\n\n\nconst fn_flavors = @[]\n  (function(){}).constructor\n  (function *(){}).constructor\n  (async function(){}).constructor\n  (async function *(){}).constructor\n\nfunction checkSyntax(expr) ::\n  for let FuncKind of fn_flavors ::\n    try ::\n      new FuncKind @ `return ${expr}`\n      return true\n    catch err ::\n\n  return false\n\n\nfunction _regexp_join(pre, rx_options, post) ::\n  rx_options = [... rx_options]\n    .flatMap @ rx => rx ? [rx.source] : []\n  return new RegExp(`${pre}(?:${rx_options.join('|')})${post}`)\n\n","import { at_offside_map, extra_jsy_ops, op_template_str } from './jsy_operators.jsy'\nimport { checkOptionalComma } from './optional_comma.jsy'\n\nconst rx_leading_space = /^[ \\t]+/ ;\n\nconst root_head = Object.freeze @: __proto__: null\n\nexport const transpile_visitor = @{}\n  __proto__: null\n\n  *ast_iter(jsy_ast) ::\n    this.start()\n\n    let ln, fin\n    for ln of jsy_ast ::\n      fin = this.ast_line(ln)\n      yield `${fin?.join('') ?? fin ?? ''}\\n`\n\n    fin = this.finish()\n    yield `${fin?.join('') ?? fin ?? ''}\\n`\n\n\n  ast_line(ln) ::\n    if ln.is_blank ::\n      return this.blank_line(ln)\n\n    this.start_line(ln)\n    this.v$offside_indent(ln.indent)\n\n    let prev = ln.indent\n    for let part of ln.content ::\n      let fn_visit = `v$${part.type}`\n      if undefined === this[fn_visit] ::\n        throw new Error @ `JSY transpile function \"${fn_visit}\" not found`\n\n      this[fn_visit]( part, ln, prev )\n      prev = part\n\n    return this.finish_line(ln)\n\n  start() ::\n    this.lineno = 0\n    this.head = root_head\n\n  finish() ::\n    if root_head !== this.head ::\n      throw new Error @ 'Excess stack at finish'\n\n  blank_line(ln) ::\n    this.lineno ++\n\n  start_line(ln) ::\n    this.lineno ++\n    this.cur_ln = ln\n    let line_src = this._cur = []\n    line_src.finish_ops = []\n\n  finish_line(ln) ::\n    let line_src = this._cur\n    for let fn of line_src.finish_ops || [] ::\n      line_src = fn(line_src, ln)\n\n    let comma_body = this.head.comma_body\n    if undefined !== comma_body ::\n      comma_body.push @ '\\n'\n\n    return line_src\n\n  emit_raw(src) ::\n    if src :: this._cur.push @ src\n\n  emit(src, loc_start) ::\n    if loc_start && this.addSourceMapping ::\n      const column = this._cur.join('').length\n      this.addSourceMapping @:\n        generated: @{} line: this.lineno, column\n        original: @{} line: loc_start.line, column: loc_start.column\n\n    const comma_body = this.head.comma_body\n    if undefined !== comma_body ::\n      comma_body.push @ src\n\n    this._cur.push @ src\n\n  emit_indent(indent) ::\n    const cur = this._cur\n    if 0 !== cur.length ::\n      throw new Error @ `Indent must be first element of cur list`\n\n    const comma_body = this.head.comma_body\n    if undefined === comma_body ::\n      cur.push @ indent\n      return\n\n    comma_body.splice @ 0, comma_body.length,\n      comma_body.join('').trimLeft()\n\n    if comma_body.len_inner != this.cur_ln.len_indent ::\n      cur.push @ indent\n      return\n\n    cur.push @ indent || ' '\n\n    let finish_commas = (cur) => ::\n      const pre = comma_body[0]\n      if ! pre :: return cur\n\n      const post = comma_body.slice(1).join('')\n      const opt_comma = this.checkOptionalComma @ comma_body.op, pre, post\n      if opt_comma ::\n        if cur[0].length > 1 ::\n          cur[0] = cur[0].replace(/\\s\\s$/, ', ')\n        else cur[0] = ','\n        comma_body.shift()\n      return cur\n\n    cur.finish_ops.push @ finish_commas\n\n  _checkOptionalComma: checkOptionalComma\n  checkOptionalComma\n\n  stack_push(op, p) ::\n    if op.foldTop && this.head.isFoldable ::\n      this.stack_pop()\n\n    if null === op.post ::\n      if op.pre :: this.emit @ op.pre\n      return\n\n    const {len_indent, loc} = p\n    const head = @{} __proto__: this.head\n      op, len_indent, loc\n      isFoldable: op.isFoldable\n      nestBreak: op.nestBreak\n\n    if ',' == op.implicitSep ::\n      const comma_body = head.comma_body = []\n      comma_body.op = op\n      comma_body.len_inner = this.cur_ln.len_inner\n    else head.comma_body = undefined\n\n    if op.in_nested_block ::\n      head.in_nested_block = true\n      head.nested_block_indent = len_indent\n\n    head.tail = [this.head].concat(head.tail || [])\n\n    let src_pre = head.op.pre\n    if src_pre :: this.emit @ src_pre\n\n    this.head = head\n\n  stack_pop(c) ::\n    let head = this.head\n    let next = head.tail[0]\n    this.head = next\n\n    if next.comma_body ::\n      let substitute = head.op.substitute ?? @ // explicit substution\n        ',' == head.op.implicitSep ? 'expr' // is a comma-based expression\n        : /[\\)\\]]\\s*$/.test(head.op.post) ? 'expr' // ends as call or index expr\n        : null\n\n      if null != substitute ::\n        // internal op was an expression; simplify for comma_body\n        next.comma_body.push(` ${substitute} `)\n\n    let src_post = head.op.post\n    if src_post ::\n      this.emit @ c ? ' '+src_post : src_post\n\n  v$jsy_unknown(p) ::\n    throw p.loc.start.syntaxError @\n      `JSY unknown operator \"${p.op}\"`\n\n  v$jsy_kw(p) ::\n    const kw_op = p.explicit\n      ? extra_jsy_ops.kw_explicit\n      : extra_jsy_ops.kw_normal\n\n    this.stack_push @ kw_op.kwExpandOp(p), p\n\n  v$jsy_op(p) ::\n    this._jsy_op @ at_offside_map[p.op], p\n\n  v$jsy_op_args(p) ::\n    this._jsy_op @ at_offside_map[p.op], p\n\n  _jsy_op(jsy_op, p) ::\n    if ! jsy_op ::\n      throw new Error @ `JSY op handler not found for \"${p.op}\"`\n\n    if jsy_op.warn :: jsy_op.warn(p)\n\n    if jsy_op.opResolve ::\n      jsy_op = validate_jsy_op_item @ jsy_op.opResolve(p)\n      if jsy_op.warn :: jsy_op.warn(p)\n\n    this._jsy_op_exec(jsy_op, p)\n\n  _jsy_op_exec(jsy_op, p) ::\n    if jsy_op.is_kw_close ::\n      this._dedent_nested_block(p)\n\n    this.stack_push @ jsy_op, p\n\n\n  _dedent_nested_block(p) ::\n    if ! this.head.in_nested_block :: return\n\n    if null != p ::\n      p.len_indent = this.head.nested_block_indent\n\n    let c = 0, done=false\n    while this.head && this.head.in_nested_block && ! done ::\n      done = this.head.op.in_nested_block\n      this.stack_pop @ c++\n\n  _dedent_multi_ops() ::\n    if ! this.head.loc :: return\n\n    const line = this.cur_ln.loc.start.line\n    const t = this.head.tail\n      .filter @ t => t.loc && line === t.loc.start.line\n      .pop()\n\n    if undefined === t :: return\n\n    let c = 0\n    while t !== this.head && !this.head.nestBreak ::\n      this.stack_pop @ c++\n\n  v$offside_dedent(p) ::\n    if ! p.ends_with_jsy_op ::\n      this._dedent_multi_ops()\n\n    let c = 0\n    while this.head.len_indent >= p.len_dedent ::\n      this.stack_pop @ c++\n\n\n  v$offside_indent(p) ::\n    this.emit_indent @ p.indent\n\n\n  v$template_param(p) :: this._param @ extra_jsy_ops.tmpl_param, p\n  v$template_param_end(p) :: this._param_end @ p\n\n  v$jsx_param(p) :: this._param @ extra_jsy_ops.jsx_param, p\n  v$jsx_param_end(p) :: this._param_end @ p\n\n  _param(op, p) ::\n    this.stack_push @ op, p\n    this.emit_raw @ p.content\n\n  _param_end(p) ::\n    this._dedent_nested_block(p)\n    this.emit_raw @ p.content\n\n    let comma_body = this.head.comma_body\n    if undefined !== comma_body ::\n      // fixup comma_body with simplified template param\n      comma_body.push @ 'null }'\n\n\n  v$str_template(p, ln, p0) ::\n    if p.tmpl_opened ::\n      this.stack_push @ op_template_str, p\n\n    if p0 === ln.indent && p.mlctx ::\n      let indent = this._cur.pop()\n      this._cur.push @ indent.slice(p.mlctx.col)\n\n    this.emit @ p.content, p.loc.start\n\n    if p.tmpl_closed ::\n      this.stack_pop()\n      let comma_body = this.head.comma_body\n      if undefined !== comma_body ::\n        // fixup comma_body with simplified template param\n        comma_body.push @ '`tmpl_expr`'\n\n  v$src(p, ln, p0) ::\n    let content = p.content\n    if {jsy_op:1, jsy_kw:1}[p0.type] && rx_leading_space.test(content) ::\n      content = content.replace(rx_leading_space, '')\n\n    this.emit @ content, p.loc.start\n\n\n  v$preprocessor(p, ln) :: this.emit(p.content)\n  v$preprocessor_sz(p, ln) :: this.emit(p.ans)\n  v$preprocessor_inc(p, ln) ::\n    if this.inc_preprocessor ::\n      this.emit @ `//+~${p.content}`\n  v$preprocessor_exc(p, ln) ::\n    if this.inc_preprocessor ::\n      this.emit @ `//-~${p.content}`\n  v$exclude_line(p, ln) ::\n    if this.inc_preprocessor ::\n      this.emit(p.content)\n  v$exclude_part(p, ln) ::\n    if this.inc_preprocessor ::\n      this.emit(p.content)\n\n  v$str: direct_src\n  v$str1: direct_src\n  v$str2: direct_src\n\n  v$regexp: direct_src\n\n  v$jsx_frag: direct_src\n  v$jsx_frag_close: direct_src\n  v$jsx_tag: direct_src\n  v$jsx_tag_part: direct_src\n  v$jsx_tag_close: direct_src\n  v$jsx_attr_name: direct_src\n  v$jsx_attr_name_only: direct_src\n  v$jsx_attr_str1: direct_src\n  v$jsx_attr_str2: direct_src\n  v$jsx_content: direct_src\n  v$jsx_content_expr: direct_src\n\n  v$hashbang: raw_src\n  v$comment_eol: raw_src\n  v$comment_multi: raw_src\n\n\nfunction raw_src(p) :: this.emit_raw @ p.content\nfunction direct_src(p) :: this.emit @ p.content, p.loc.start\n\nfunction validate_jsy_op_item(jsy_op_item) ::\n  let {pre, post} = jsy_op_item\n\n  if null !== pre && 'string' !== typeof pre ::\n    throw new Error @ 'Invalid resolved jsy_op_item.pre result'\n  if null !== post && 'string' !== typeof post ::\n    throw new Error @ 'Invalid resolved jsy_op_item.post result'\n\n  return jsy_op_item\n\n","export const version = 'GITREPO'\n","import { jsy_scan } from './scan.jsy'\nimport { basic_preprocessor } from './preprocess.jsy'\nimport { preprocess_visitor } from './preprocess_visitor.jsy'\nimport { transpile_visitor } from './jsy_visitor.jsy'\nimport { sourcemap_comment } from './utils.jsy'\n\n\nexport function jsy_transpile(ast, feedback) ::\n  return [... jsy_iter_transpile(ast, feedback)]\n    .join('') // join the stream that has embedded newlines\n    .replace(/\\s+$/, '\\n') // trimming excess whitespace at end into single newline\n\nexport function * jsy_iter_transpile(ast, feedback) ::\n  if ! feedback :: feedback = {}\n\n  if 'string' === typeof ast ::\n    ast = jsy_scan(ast, feedback)\n\n\n  let preprocess = feedback.preprocessor?.()\n    ?? basic_preprocessor(feedback.defines)\n\n  if preprocess :: // preprocessor pass\n    let pp_visitor = @{}\n      __proto__: preprocess_visitor\n      ... feedback.preprocess_visitor\n      preprocess\n\n    ast = pp_visitor.ast_iter(ast)\n\n\n  :: // transpile pass\n    let jsy_visitor = @{}\n      __proto__: transpile_visitor\n      ... feedback.visitor\n\n    if feedback.checkOptionalComma ::\n      jsy_visitor.checkOptionalComma = feedback.checkOptionalComma\n\n    if feedback.addSourceMapping ::\n      jsy_visitor.addSourceMapping = feedback.addSourceMapping\n\n\n    yield * jsy_visitor.ast_iter(ast)\n\n\n  :: // sourcemap output\n    let srcmap = feedback.inlineSourceMap?.()\n    if srcmap ::\n      yield sourcemap_comment(srcmap, '\\n')\n    \n\nexport { version } from './version.js'\nexport @{}\n  jsy_transpile as default\n\n","import tiny_sourcemap from 'tiny-source-map'\nimport { jsy_transpile, version } from './transpile.jsy'\n\nconst _jsy_srcmap_ctx = @{}\n  i: 1, ts: Date.now().toString(36)\n\nexport function jsy_transpile_srcmap(jsy_src, ... args) ::\n  let source_ref = null == args[0] || 'object' !== typeof args[0] ? args.shift() : null\n  let opt = args.pop() || {}\n\n  if null == source_ref ::\n    source_ref = `<jsy-${_jsy_srcmap_ctx.i++}-${_jsy_srcmap_ctx.ts}>.jsy`\n\n  const srcmap = !opt.sourcemap ? null\n    : opt.create_sourcemap\n      ? opt.create_sourcemap()\n      : tiny_sourcemap()\n\n  if null !== srcmap ::\n    srcmap.setSourceContent @ source_ref, jsy_src\n\n  let code = jsy_transpile @ jsy_src, @{}\n    addSourceMapping(arg) ::\n      if null == srcmap :: return\n      if source_ref ::\n        arg.source = source_ref\n      srcmap.addMapping(arg)\n\n    inlineSourceMap() ::\n      if srcmap && 'inline' == opt.sourcemap ::\n        return srcmap.toString()\n\n    ... opt\n\n  return opt.as_rec ? {code, srcmap} : code\n\nexport { version, jsy_transpile_srcmap as default }\n","'use strict';\n\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\nconst SEP = '/';\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR,\n  SEP\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,\n  SEP: '\\\\'\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n","/*global navigator*/\n'use strict';\n\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.isWindows = () => {\n  if (typeof navigator !== 'undefined' && navigator.platform) {\n    const platform = navigator.platform.toLowerCase();\n    return platform === 'win32' || platform === 'windows';\n  }\n\n  if (typeof process !== 'undefined' && process.platform) {\n    return process.platform === 'win32';\n  }\n\n  return false;\n};\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n\nexports.basename = (path, { windows } = {}) => {\n  const segs = path.split(windows ? /[\\\\/]/ : '/');\n  const last = segs[segs.length - 1];\n\n  if (last === '') {\n    return segs[segs.length - 2];\n  }\n\n  return last;\n};\n","'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(opts.windows);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.output = (prev.output || prev.value) + tok.value;\n      prev.value += tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(opts.windows);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = opts.windows;\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(utils.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n","'use strict';\n\nconst pico = require('./lib/picomatch');\nconst utils = require('./lib/utils');\n\nfunction picomatch(glob, options, returnState = false) {\n  // default to os.platform()\n  if (options && (options.windows === null || options.windows === undefined)) {\n    // don't mutate the original options object\n    options = { ...options, windows: utils.isWindows() };\n  }\n\n  return pico(glob, options, returnState);\n}\n\nObject.assign(picomatch, pico);\nmodule.exports = picomatch;\n","import { extname, win32, posix, isAbsolute, resolve } from 'path';\nimport { walk } from 'estree-walker';\nimport pm from 'picomatch';\n\nconst addExtension = function addExtension(filename, ext = '.js') {\n    let result = `${filename}`;\n    if (!extname(filename))\n        result += ext;\n    return result;\n};\n\nconst extractors = {\n    ArrayPattern(names, param) {\n        for (const element of param.elements) {\n            if (element)\n                extractors[element.type](names, element);\n        }\n    },\n    AssignmentPattern(names, param) {\n        extractors[param.left.type](names, param.left);\n    },\n    Identifier(names, param) {\n        names.push(param.name);\n    },\n    MemberExpression() { },\n    ObjectPattern(names, param) {\n        for (const prop of param.properties) {\n            // @ts-ignore Typescript reports that this is not a valid type\n            if (prop.type === 'RestElement') {\n                extractors.RestElement(names, prop);\n            }\n            else {\n                extractors[prop.value.type](names, prop.value);\n            }\n        }\n    },\n    RestElement(names, param) {\n        extractors[param.argument.type](names, param.argument);\n    }\n};\nconst extractAssignedNames = function extractAssignedNames(param) {\n    const names = [];\n    extractors[param.type](names, param);\n    return names;\n};\n\nconst blockDeclarations = {\n    const: true,\n    let: true\n};\nclass Scope {\n    constructor(options = {}) {\n        this.parent = options.parent;\n        this.isBlockScope = !!options.block;\n        this.declarations = Object.create(null);\n        if (options.params) {\n            options.params.forEach((param) => {\n                extractAssignedNames(param).forEach((name) => {\n                    this.declarations[name] = true;\n                });\n            });\n        }\n    }\n    addDeclaration(node, isBlockDeclaration, isVar) {\n        if (!isBlockDeclaration && this.isBlockScope) {\n            // it's a `var` or function node, and this\n            // is a block scope, so we need to go up\n            this.parent.addDeclaration(node, isBlockDeclaration, isVar);\n        }\n        else if (node.id) {\n            extractAssignedNames(node.id).forEach((name) => {\n                this.declarations[name] = true;\n            });\n        }\n    }\n    contains(name) {\n        return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);\n    }\n}\nconst attachScopes = function attachScopes(ast, propertyName = 'scope') {\n    let scope = new Scope();\n    walk(ast, {\n        enter(n, parent) {\n            const node = n;\n            // function foo () {...}\n            // class Foo {...}\n            if (/(?:Function|Class)Declaration/.test(node.type)) {\n                scope.addDeclaration(node, false, false);\n            }\n            // var foo = 1\n            if (node.type === 'VariableDeclaration') {\n                const { kind } = node;\n                const isBlockDeclaration = blockDeclarations[kind];\n                node.declarations.forEach((declaration) => {\n                    scope.addDeclaration(declaration, isBlockDeclaration, true);\n                });\n            }\n            let newScope;\n            // create new function scope\n            if (node.type.includes('Function')) {\n                const func = node;\n                newScope = new Scope({\n                    parent: scope,\n                    block: false,\n                    params: func.params\n                });\n                // named function expressions - the name is considered\n                // part of the function's scope\n                if (func.type === 'FunctionExpression' && func.id) {\n                    newScope.addDeclaration(func, false, false);\n                }\n            }\n            // create new for scope\n            if (/For(?:In|Of)?Statement/.test(node.type)) {\n                newScope = new Scope({\n                    parent: scope,\n                    block: true\n                });\n            }\n            // create new block scope\n            if (node.type === 'BlockStatement' && !parent.type.includes('Function')) {\n                newScope = new Scope({\n                    parent: scope,\n                    block: true\n                });\n            }\n            // catch clause has its own block scope\n            if (node.type === 'CatchClause') {\n                newScope = new Scope({\n                    parent: scope,\n                    params: node.param ? [node.param] : [],\n                    block: true\n                });\n            }\n            if (newScope) {\n                Object.defineProperty(node, propertyName, {\n                    value: newScope,\n                    configurable: true\n                });\n                scope = newScope;\n            }\n        },\n        leave(n) {\n            const node = n;\n            if (node[propertyName])\n                scope = scope.parent;\n        }\n    });\n    return scope;\n};\n\n// Helper since Typescript can't detect readonly arrays with Array.isArray\nfunction isArray(arg) {\n    return Array.isArray(arg);\n}\nfunction ensureArray(thing) {\n    if (isArray(thing))\n        return thing;\n    if (thing == null)\n        return [];\n    return [thing];\n}\n\nconst normalizePathRegExp = new RegExp(`\\\\${win32.sep}`, 'g');\nconst normalizePath = function normalizePath(filename) {\n    return filename.replace(normalizePathRegExp, posix.sep);\n};\n\nfunction getMatcherString(id, resolutionBase) {\n    if (resolutionBase === false || isAbsolute(id) || id.startsWith('**')) {\n        return normalizePath(id);\n    }\n    // resolve('') is valid and will default to process.cwd()\n    const basePath = normalizePath(resolve(resolutionBase || ''))\n        // escape all possible (posix + win) path characters that might interfere with regex\n        .replace(/[-^$*+?.()|[\\]{}]/g, '\\\\$&');\n    // Note that we use posix.join because:\n    // 1. the basePath has been normalized to use /\n    // 2. the incoming glob (id) matcher, also uses /\n    // otherwise Node will force backslash (\\) on windows\n    return posix.join(basePath, normalizePath(id));\n}\nconst createFilter = function createFilter(include, exclude, options) {\n    const resolutionBase = options && options.resolve;\n    const getMatcher = (id) => id instanceof RegExp\n        ? id\n        : {\n            test: (what) => {\n                // this refactor is a tad overly verbose but makes for easy debugging\n                const pattern = getMatcherString(id, resolutionBase);\n                const fn = pm(pattern, { dot: true });\n                const result = fn(what);\n                return result;\n            }\n        };\n    const includeMatchers = ensureArray(include).map(getMatcher);\n    const excludeMatchers = ensureArray(exclude).map(getMatcher);\n    if (!includeMatchers.length && !excludeMatchers.length)\n        return (id) => typeof id === 'string' && !id.includes('\\0');\n    return function result(id) {\n        if (typeof id !== 'string')\n            return false;\n        if (id.includes('\\0'))\n            return false;\n        const pathId = normalizePath(id);\n        for (let i = 0; i < excludeMatchers.length; ++i) {\n            const matcher = excludeMatchers[i];\n            if (matcher instanceof RegExp) {\n                matcher.lastIndex = 0;\n            }\n            if (matcher.test(pathId))\n                return false;\n        }\n        for (let i = 0; i < includeMatchers.length; ++i) {\n            const matcher = includeMatchers[i];\n            if (matcher instanceof RegExp) {\n                matcher.lastIndex = 0;\n            }\n            if (matcher.test(pathId))\n                return true;\n        }\n        return !includeMatchers.length;\n    };\n};\n\nconst reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';\nconst builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';\nconst forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(' '));\nforbiddenIdentifiers.add('');\nconst makeLegalIdentifier = function makeLegalIdentifier(str) {\n    let identifier = str\n        .replace(/-(\\w)/g, (_, letter) => letter.toUpperCase())\n        .replace(/[^$_a-zA-Z0-9]/g, '_');\n    if (/\\d/.test(identifier[0]) || forbiddenIdentifiers.has(identifier)) {\n        identifier = `_${identifier}`;\n    }\n    return identifier || '_';\n};\n\nfunction stringify(obj) {\n    return (JSON.stringify(obj) || 'undefined').replace(/[\\u2028\\u2029]/g, (char) => `\\\\u${`000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);\n}\nfunction serializeArray(arr, indent, baseIndent) {\n    let output = '[';\n    const separator = indent ? `\\n${baseIndent}${indent}` : '';\n    for (let i = 0; i < arr.length; i++) {\n        const key = arr[i];\n        output += `${i > 0 ? ',' : ''}${separator}${serialize(key, indent, baseIndent + indent)}`;\n    }\n    return `${output}${indent ? `\\n${baseIndent}` : ''}]`;\n}\nfunction serializeObject(obj, indent, baseIndent) {\n    let output = '{';\n    const separator = indent ? `\\n${baseIndent}${indent}` : '';\n    const entries = Object.entries(obj);\n    for (let i = 0; i < entries.length; i++) {\n        const [key, value] = entries[i];\n        const stringKey = makeLegalIdentifier(key) === key ? key : stringify(key);\n        output += `${i > 0 ? ',' : ''}${separator}${stringKey}:${indent ? ' ' : ''}${serialize(value, indent, baseIndent + indent)}`;\n    }\n    return `${output}${indent ? `\\n${baseIndent}` : ''}}`;\n}\nfunction serialize(obj, indent, baseIndent) {\n    if (typeof obj === 'object' && obj !== null) {\n        if (Array.isArray(obj))\n            return serializeArray(obj, indent, baseIndent);\n        if (obj instanceof Date)\n            return `new Date(${obj.getTime()})`;\n        if (obj instanceof RegExp)\n            return obj.toString();\n        return serializeObject(obj, indent, baseIndent);\n    }\n    if (typeof obj === 'number') {\n        if (obj === Infinity)\n            return 'Infinity';\n        if (obj === -Infinity)\n            return '-Infinity';\n        if (obj === 0)\n            return 1 / obj === Infinity ? '0' : '-0';\n        if (obj !== obj)\n            return 'NaN'; // eslint-disable-line no-self-compare\n    }\n    if (typeof obj === 'symbol') {\n        const key = Symbol.keyFor(obj);\n        // eslint-disable-next-line no-undefined\n        if (key !== undefined)\n            return `Symbol.for(${stringify(key)})`;\n    }\n    if (typeof obj === 'bigint')\n        return `${obj}n`;\n    return stringify(obj);\n}\n// isWellFormed exists from Node.js 20\nconst hasStringIsWellFormed = 'isWellFormed' in String.prototype;\nfunction isWellFormedString(input) {\n    // @ts-expect-error String::isWellFormed exists from ES2024. tsconfig lib is set to ES6\n    if (hasStringIsWellFormed)\n        return input.isWellFormed();\n    // https://github.com/tc39/proposal-is-usv-string/blob/main/README.md#algorithm\n    return !/\\p{Surrogate}/u.test(input);\n}\nconst dataToEsm = function dataToEsm(data, options = {}) {\n    var _a, _b;\n    const t = options.compact ? '' : 'indent' in options ? options.indent : '\\t';\n    const _ = options.compact ? '' : ' ';\n    const n = options.compact ? '' : '\\n';\n    const declarationType = options.preferConst ? 'const' : 'var';\n    if (options.namedExports === false ||\n        typeof data !== 'object' ||\n        Array.isArray(data) ||\n        data instanceof Date ||\n        data instanceof RegExp ||\n        data === null) {\n        const code = serialize(data, options.compact ? null : t, '');\n        const magic = _ || (/^[{[\\-\\/]/.test(code) ? '' : ' '); // eslint-disable-line no-useless-escape\n        return `export default${magic}${code};`;\n    }\n    let maxUnderbarPrefixLength = 0;\n    for (const key of Object.keys(data)) {\n        const underbarPrefixLength = (_b = (_a = /^(_+)/.exec(key)) === null || _a === void 0 ? void 0 : _a[0].length) !== null && _b !== void 0 ? _b : 0;\n        if (underbarPrefixLength > maxUnderbarPrefixLength) {\n            maxUnderbarPrefixLength = underbarPrefixLength;\n        }\n    }\n    const arbitraryNamePrefix = `${'_'.repeat(maxUnderbarPrefixLength + 1)}arbitrary`;\n    let namedExportCode = '';\n    const defaultExportRows = [];\n    const arbitraryNameExportRows = [];\n    for (const [key, value] of Object.entries(data)) {\n        if (key === makeLegalIdentifier(key)) {\n            if (options.objectShorthand)\n                defaultExportRows.push(key);\n            else\n                defaultExportRows.push(`${key}:${_}${key}`);\n            namedExportCode += `export ${declarationType} ${key}${_}=${_}${serialize(value, options.compact ? null : t, '')};${n}`;\n        }\n        else {\n            defaultExportRows.push(`${stringify(key)}:${_}${serialize(value, options.compact ? null : t, '')}`);\n            if (options.includeArbitraryNames && isWellFormedString(key)) {\n                const variableName = `${arbitraryNamePrefix}${arbitraryNameExportRows.length}`;\n                namedExportCode += `${declarationType} ${variableName}${_}=${_}${serialize(value, options.compact ? null : t, '')};${n}`;\n                arbitraryNameExportRows.push(`${variableName} as ${JSON.stringify(key)}`);\n            }\n        }\n    }\n    const arbitraryExportCode = arbitraryNameExportRows.length > 0\n        ? `export${_}{${n}${t}${arbitraryNameExportRows.join(`,${n}${t}`)}${n}};${n}`\n        : '';\n    const defaultExportCode = `export default${_}{${n}${t}${defaultExportRows.join(`,${n}${t}`)}${n}};${n}`;\n    return `${namedExportCode}${arbitraryExportCode}${defaultExportCode}`;\n};\n\n// TODO: remove this in next major\nvar index = {\n    addExtension,\n    attachScopes,\n    createFilter,\n    dataToEsm,\n    extractAssignedNames,\n    makeLegalIdentifier,\n    normalizePath\n};\n\nexport { addExtension, attachScopes, createFilter, dataToEsm, index as default, extractAssignedNames, makeLegalIdentifier, normalizePath };\n//# sourceMappingURL=index.js.map\n","import { jsy_transpile_srcmap, version } from './jsy/with_srcmap.jsy'\nimport { createFilter } from '@rollup/pluginutils'\n\nexport default function jsy_rollup_plugin(config) {\n  config = {\n    include: ['**/*.jsy'],\n    exclude: ['node_modules/**'],\n    ... config }\n\n  const filter = createFilter(config.include, config.exclude)\n  const sourcemap = false !== config.sourcemap && false !== config.sourceMap\n  let { preprocessor, defines } = config\n  if (! preprocessor && config.preprocess)\n    preprocessor = () => config.preprocess\n\n  return {\n    name: `jsy-${version}`,\n    transform(code, id) {\n      if (! filter(id)) return\n\n      try {\n        let jsy = jsy_transpile_srcmap( code, id, {\n          ... config.jsy, as_rec: true,\n          preprocessor, defines,\n          sourcemap, })\n\n        return { code: jsy.code, map: jsy.srcmap.toJSON() }\n\n      } catch (err) {\n        if (undefined !== err.src_loc)\n          this.error(err, err.src_loc.pos)\n        else throw err\n      }\n    }\n  }\n}\n"],"names":["tiny_sourcemap","require$$0","require$$1","require$$2","require$$3","picomatch_1"],"mappings":"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","x_google_ignoreList":[0,24,25,26,27,28,29,30]}