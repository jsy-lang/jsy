import { at_offside_map, kw_jsy_op  } from './jsy_operators.jsy'
import scan_jsy from './scan_jsy.jsy'


transpile_jsy.transpile_jsy = transpile_jsy
transpile_jsy.jsy_transpile = transpile_jsy

export default transpile_jsy
export const jsy_transpile = transpile_jsy
export function transpile_jsy(jsy_ast, feedback) ::
  if ! feedback :: feedback = {}
  if 'string' === typeof jsy_ast ::
    jsy_ast = scan_jsy(jsy_ast, feedback)

  const visitor = @{} __proto__: transpile_visitor

  if feedback.addSourceMapping ::
    Object.defineProperties @ visitor, @{}
      addSourceMapping: @{} value: feedback.addSourceMapping

  const lines = []
  visitor.start()

  for const ln of jsy_ast ::
    if ln.is_blank ::
      visitor.blank_line(ln)
      continue

    //debug_ln @ ln
    visitor.start_line(ln)
    visitor.v$offside_indent(ln.indent)

    for const part of ln.content ::
      const key = `v$${part.type}`
      visitor[key] @ part

    lines.push @ visitor.finish_line(ln).join('')

  visitor.finish()

  if feedback.inlineSourceMap ::
    const srcmap = feedback.inlineSourceMap()
    if srcmap ::
      lines.push @ sourcemap_comment @ srcmap

  return lines.join('\n')

    
function debug_ln(ln) ::
  if ln.is_blank :: return
  console.log()
  console.dir @ ln.raw.line
  console.dir @: types: ln.content.map @ e => e.type



const root_head = Object.freeze @: __proto__: null

const transpile_visitor = @{}
  __proto__: null
  start() ::
    this.lineno = 0
    this.head = root_head

  finish() ::
    if root_head !== this.head ::
      throw new Error @ 'Excess stack at finish'

  blank_line(ln) ::
    this.lineno ++

  start_line(ln) ::
    this.lineno ++
    this.cur_ln = ln
    this._cur = []

  finish_line(ln) ::
    let line_src = this._cur
    this._cur = this.cur_ln = null
    if 'function' === typeof line_src.finish_commas ::
      line_src = line_src.finish_commas(line_src)

    const comma_body = this.head.comma_body
    if undefined !== comma_body ::
      comma_body.push @ '\n'

    return line_src

  emit_indent(indent) ::
    const cur = this._cur
    if 0 !== cur.length ::
      throw new Error @ `Indent must be first element of cur list`

    const comma_body = this.head.comma_body
    if undefined === comma_body ::
      cur.push @ indent
      return

    cur.push @ indent || ' '

    comma_body.splice @ 0, comma_body.length,
      comma_body.join('').trimLeft()

    cur.finish_commas = cur => ::
      const pre = comma_body[0]
      if ! pre :: return cur

      const post = comma_body.slice(1).join('')
      const opt_comma = this.checkOptionalCommaSyntax @ comma_body.op, pre, post
      if opt_comma ::
        cur[0] = cur[0].replace(/\s$/, ',')
        comma_body.shift()
      return cur

  checkOptionalCommaSyntax

  emit(src, loc_start) ::
    if loc_start && this.addSourceMapping ::
      const column = this._cur.join('').length
      this.addSourceMapping @:
        generated: @{} line: this.lineno, column
        original: @{} line: loc_start.line, column: loc_start.column

    const comma_body = this.head.comma_body
    if undefined !== comma_body ::
      comma_body.push @ src

    this._cur.push @ src

  stack_push(op, p) ::
    const {len_indent, loc} = p
    const head = @{} __proto__: this.head
      op, len_indent, loc
      nestInner: op.nestInner

    if op.implicitCommas ::
      head.comma_body = []
      head.comma_body.op = op
    else head.comma_body = undefined

    if op.in_kw_block ::
      head.in_kw_block = true
      head.kw_block_indent = len_indent

    head.tail = [this.head].concat(head.tail || [])

    const src = head.op.pre
    if src :: this.emit @ src

    this.head = head

  stack_pop() ::
    const head = this.head
    this.head = head.tail[0]

    const src = head.op.post
    if src :: this.emit @ src


  v$jsy_kw(p) ::
    const kw_op = p.explicit
      ? kw_jsy_op.explicit
      : kw_jsy_op.normal

    this.stack_push @ kw_op, p

  v$jsy_op(p) ::
    const jsy_op = at_offside_map[p.op]

    if jsy_op.is_kw_close && this.head.in_kw_block ::
      p.len_indent = this.head.kw_block_indent
      while this.head.in_kw_block ::
        this.stack_pop()

    this.stack_push @ jsy_op, p


  _dedent_multi_ops() ::
    if ! this.head.loc :: return

    const line = this.cur_ln.loc.start.line
    const t = this.head.tail
      .filter @ t => t.loc && line === t.loc.start.line
      .pop()

    if undefined === t :: return

    while t !== this.head && this.head.nestInner ::
      this.stack_pop()

  v$offside_dedent(p) ::
    if ! p.ends_with_jsy_op ::
      this._dedent_multi_ops()

    while this.head.len_indent >= p.len_dedent ::
      this.stack_pop()


  v$offside_indent(p) ::
    this.emit_indent @ p.indent

  v$src: direct_srcmap
  v$str_single: direct_srcmap
  v$str_double: direct_srcmap
  v$str_multi: direct_srcmap
  v$comment_eol: direct_noloc
  v$comment_multi: direct_noloc

function direct_srcmap(p) :: this.emit @ p.content, p.loc.start
function direct_noloc(p) :: this.emit @ p.content


const rx_dangling = /([\{\[\(])\s*$|(=>)\s*$/ ;
const dangling_pair = {'{':'}', '(':')', '[':']', '=>': 'null'}
function checkOptionalCommaSyntax(op, pre_body, post_body) ::
  let dangling = rx_dangling.exec(post_body) ;
  if dangling ::
    dangling = [].filter.call(dangling, Boolean)
    post_body += dangling_pair[dangling[1]]

  if checkSyntax @ `${op.pre} ${pre_body} ${post_body} ${op.post}` ::
    return false

  return checkSyntax @ `${op.pre} ${pre_body} , ${post_body} ${op.post}`

function checkSyntax(expr) ::
  // use built-in Function from source to check syntax
  try ::
    new Function @ `return ${expr}`
    return true
  catch err ::
    return false


export function sourcemap_comment(srcmap_json) ::
  if 'string' !== typeof srcmap_json ::
    srcmap_json = JSON.stringify(srcmap_json)

  const b64 = 'undefined' !== typeof Buffer
    ? Buffer.from(srcmap_json).toString('base64')
    : window.btoa @ unescape @ encodeURIComponent @ srcmap_json

  return `//# sourceMappingURL=data:application/json;charset=utf-8;base64,${b64}`

