import scan_offside_contexts from './basic_offside_contexts.jsy'
import { js_context_scanners } from './scan_javascript.jsy'
import { scanner_nestedSrc } from './scan_clike.jsy'
import { RegExpScanner, MultiLineScanner, DynamicScanner, NestedRegExpScanner } from './context_scanner.jsy'



export const scanner_xmlAttrSingle =
  new NestedRegExpScanner @:
      description: 'XML Single quote attribute literal'
      op: 'xmlattrstr'
      rx_open: /(')/, rx_close: /(?:\\.|[^'])*(')/,

export const scanner_xmlAttrDouble =
  new NestedRegExpScanner @:
      description: 'Double quote string literal'
      description: 'XML Double quote attribute literal'
      op: 'xmlattrstr'
      rx_open: /(")/, rx_close: /(?:\\.|[^"])*(")/,

export const scanner_jsx =
  new DynamicScanner @:
      description: 'Embedded JSX expression'
      example: '<section>content</section>'
      op: 'jsx', op_leader: 'jsx0'
      kind:'<'
      rx_open: /(<)([a-zA-Z0-9_:.\-]*)\s*(\/?>|[{]|[a-zA-Z0-9_:\-]+=|$)/
      rx_close: /.*$/
      rx_leader_open: /<leader/
      rx_leader_close: /(?:.*?)([{'"]|<leader>|<\/leader>)/

      nestMatch(close, ctx, dispatch, hostScanner) ::
        if '<' === close[0] ::
          if '/' === close[1] ::
            return true
          ctx.scanner = hostScanner.continueScanner(ctx)
          return

        const nested = this.nesting[close]
        if nested ::
          ctx.scanner = hostScanner.continueScanner(ctx)
          return this._nestWith @ nested,
            ctx, dispatch, hostScanner

      nestingTrim: @{} "'": true, '"': true
      nesting: @{}
        '{': jsxArgNesting
        "'": scanner_xmlAttrSingle
        '"': scanner_xmlAttrDouble

function jsxArgNesting(ctx, dispatch, hostScanner) ::
  const src = scanner_nestedSrc.withOuter @:
    scanner: hostScanner.continueScanner(ctx)
    stack: @[] '{' // from the template parameter opening
    ast_end: 'jsx_param_end'

  src.emit_ast @ ctx, '', 'jsx_param'

  ctx.scanner = dispatch.cloneWithOps @: src



export const jsx_context_scanners = Object.freeze @ js_context_scanners.concat @#
  scanner_jsx

export default scan_javascript_with_jsx
export function scan_javascript_with_jsx(source, feedback) ::
  return scan_offside_contexts(source, feedback, jsx_context_scanners)


