export default bind_context_scanner
export function bind_context_scanner(context_scanners) ::
  if ! Object.isFrozen(context_scanners) || ! Array.isArray(context_scanners) ::
    throw new TypeError @ `Expected a frozen array of context scanners`

  const cache = bind_context_scanner.cache || new WeakMap()
  if cache !== bind_context_scanner.cache ::
    bind_context_scanner.cache = cache

  let res = cache.get(context_scanners)
  if undefined === res ::
    res = compile_context_scanner(context_scanners)
    cache.set(context_scanners, res)
  return res


function compile_context_scanner(context_scanners) ::
  const scn_multiline={}, scn_ops={}
  const {rx_firstline, rx_content} = build_composite_regexp()

  return context_scanner


  function context_scanner(offside_lines) ::
    let ctx = {}
    for const ln of offside_lines ::
      if ln.is_blank ::
        delete ln.content
        continue

      const parts = []

      ctx.ln = ln
      ctx.loc_tip = ctx.loc_start = ln.content.loc.start
      ctx.ln_source = ln.content.content

      if 1 === ctx.loc_tip.line ::
        ctx.continue_scan = context_line_scanner @ ln, parts, ctx, rx_firstline

        if 0 !== parts.length ::
          ln.content = parts
          continue

      if undefined !== ctx.continue_scan ::
        ctx.continue_scan = ctx.continue_scan @ ln, parts, ctx
        if undefined !== ctx.continue_scan ::
          ln.content = parts
          continue

      ctx.continue_scan = context_line_scanner @ ln, parts, ctx, rx_content

      if 0 === parts.length ::
        throw new Error @ `No parts generated by context scanner`

      ln.content = parts

    return offside_lines

  function context_line_scanner(ln, parts, ctx, rx_scanner) ::
    ctx.continue_scan = undefined
    rx_scanner.lastIndex = ctx.loc_tip.pos - ctx.loc_start.pos
    while true ::

      let start = ctx.loc_tip
      let idx0 = start.pos - ctx.loc_start.pos
      rx_scanner.lastIndex = idx0
      const match = rx_scanner.exec(ctx.ln_source)


      if null === match ::
        if idx0 === ctx.ln_source.length ::
          return // no more content

        else if rx_firstline === rx_scanner ::
          return // no default emit

        // last source of the current line
        const content = ctx.ln_source.slice(idx0)
        const end = ctx.loc_tip = ctx.loc_tip.move(content)
        parts.push @ as_src_ast @ content, start, end
        return

      if idx0 !== match.index ::
        const content = ctx.ln_source.slice(idx0, match.index)
        const end = ctx.loc_tip = ctx.loc_tip.move(content)
        parts.push @ as_src_ast @ content, start, end
        start = ctx.loc_tip; idx0 = start.pos - ctx.loc_start.pos

      const op = scanner_op(match)

      const content = op.close ? match[0] : ctx.ln_source.slice(idx0)
      const end = ctx.loc_tip = ctx.loc_tip.move(content)
      const entry = @{}
        type: op.op
        loc: @{} start, end
        content: content

      parts.push @ entry

      if ! op.close && op.multiline ::
        return op.multiline


  function bind_multiline_scan_for(ctx_scan) ::
    const rx_cont = new RegExp @ `^${ctx_scan.rx_close.source}`
    multiline_scan.ctx_scan = ctx_scan
    return multiline_scan

    function multiline_scan(ln, parts, ctx) ::
      const idx0 = ctx.loc_tip.pos - ctx.loc_start.pos
      const match = rx_cont.exec @ ctx.ln_source.slice(idx0)
      if null === match ::
        throw new Error @ `Invalid multiline scan`

      const content = match[0]
      const start = ctx.loc_tip
      const end = ctx.loc_tip = ctx.loc_tip.move(content)

      parts.push @:
        type: ctx_scan.op
        loc: @{} start, end
        content: content

      const closed = match[1]
      if ! closed :: return multiline_scan


  function scanner_op(match) ::
    const pairs = [].filter.call(match, Boolean)
    const open = pairs[1], close = pairs[2]
    const op = scn_ops[open]
    const multiline = scn_multiline[op]
    return @{} op, open, close, multiline


  function build_composite_regexp() ::
    const regexp_all = [], regexp_firstline = []
    for const ctx_scan of context_scanners ::
      const re = `(?:${ctx_scan.rx_open.source}${ctx_scan.rx_close.source})`
      scn_ops[ctx_scan.kind] = ctx_scan.op

      if ctx_scan.firstline ::
        regexp_firstline.push @ re
        continue

      regexp_all.push @ re

      if true === ctx_scan.multiline ::
        scn_multiline[ctx_scan.op] = bind_multiline_scan_for @ ctx_scan

      else if 'function' === typeof ctx_scan.multiline ::
        scn_multiline[ctx_scan.op] = ctx_scan.multiline.bind(ctx_scan)

    return @{}
      rx_firstline: new RegExp @ regexp_firstline.join('|'), 'g'
      rx_content: new RegExp @ regexp_all.join('|'), 'g'


function as_src_ast(content, start, end) ::
  return @{} type: 'src', loc: {start, end}, content

