export default bind_context_scanner
export function bind_context_scanner(context_scanners) ::
  if ! Object.isFrozen(context_scanners) || ! Array.isArray(context_scanners) ::
    throw new TypeError @ `Expected a frozen array of context scanners`

  const cache = bind_context_scanner.cache || new WeakMap()
  if cache !== bind_context_scanner.cache ::
    bind_context_scanner.cache = cache

  let res = cache.get(context_scanners)
  if undefined === res ::
    res = compile_context_scanner(context_scanners)
    cache.set(context_scanners, res)
  return res


function compile_context_scanner(context_scanners) ::
  const scn_multiline={}, scn_ops={}
  const rx_scanner = build_composite_regexp()

  return context_scanner


  function context_scanner(offside_lines) ::
    let ctx = {}
    for const ln of offside_lines ::
      if ln.is_blank ::
        delete ln.content
        continue

      const parts = []

      ctx.ln = ln
      ctx.loc_tip = ln.content.loc.start
      ctx.ln_source = ln.content.content
      ctx.lastIndex = 0

      if ctx.continue_scan ::
        ctx.continue_scan = ctx.continue_scan @ ln, parts, ctx
        if undefined !== ctx.continue_scan ::
          ln.content = parts
          continue

        // catch lastIndex up to where continue_scan left off
        ctx.lastIndex = ctx.loc_tip.pos - ctx.loc_tip.line_pos

      ctx.continue_scan = context_line_scanner @ ln, parts, ctx

      if 0 === parts.length ::
        const {loc, content} = ln.content
        parts.push @ as_src_ast @ content, loc.start, loc.end

      ln.content = parts

    return offside_lines


  function context_line_scanner(ln, parts, ctx) ::
    rx_scanner.lastIndex = ctx.lastIndex
    while true ::

      let start = ctx.loc_tip, idx0 = rx_scanner.lastIndex
      const match = rx_scanner.exec(ctx.ln_source)

      if null === match ::
        if idx0 === ctx.ln_source.length ::
          return // no more content

        // last source of the current line
        const content = ctx.ln_source.slice(idx0)
        const end = ctx.loc_tip = ctx.loc_tip.move(content)
        parts.push @ as_src_ast @ content, start, end
        return

      if idx0 !== match.index ::
        const content = ctx.ln_source.slice(idx0, match.index)
        const end = ctx.loc_tip = ctx.loc_tip.move(content)
        parts.push @ as_src_ast @ content, start, end
        start = ctx.loc_tip; idx0 = match.index

      const op = scanner_op(match)

      const content = op.close ? match[0] : ctx.ln_source.slice(idx0)
      const end = ctx.loc_tip = ctx.loc_tip.move(content)
      const entry = @{}
        type: op.op
        loc: @{} start, end
        content: content

      parts.push @ entry

      if ! op.close && op.multiline ::
        entry.multiline = true
        return op.multiline


  function bind_multiline_scan_for(ctx_scan) ::
    const rx_cont = new RegExp @ `^${ctx_scan.rx_close.source}`
    multiline_scan.ctx_scan = ctx_scan
    return multiline_scan

    function multiline_scan(ln, parts, ctx) ::
      const match = rx_cont.exec(ctx.ln_source)
      if undefined === match ::
        throw new Error @ `Invalid multiline scan`

      const content = match[0]
      const start = ctx.loc_tip
      const end = ctx.loc_tip = ctx.loc_tip.move(content)

      parts.push @:
        type: ctx_scan.op
        loc: @{} start, end
        content: content

      const closed = match[1]
      if ! closed :: return multiline_scan


  function scanner_op(match) ::
    const pairs = [].filter.call(match, Boolean)
    const open = pairs[1], close = pairs[2]
    const op = scn_ops[open]
    const multiline = scn_multiline[op]
    return @{} op, open, close, multiline


  function build_composite_regexp() ::
    const regexp_all = []
    for const ctx_scan of context_scanners ::
      regexp_all.push @
        `(?:${ctx_scan.rx_open.source}${ctx_scan.rx_close.source})`

      scn_ops[ctx_scan.kind] = ctx_scan.op
      if true === ctx_scan.multiline ::
        scn_multiline[ctx_scan.op] = bind_multiline_scan_for @ ctx_scan

      else if 'function' === typeof ctx_scan.multiline ::
        scn_multiline[ctx_scan.op] = ctx_scan.multiline.bind(ctx_scan)

    return new RegExp @ regexp_all.join('|'), 'g'


function as_src_ast(content, start, end) ::
  return @{} type: 'src', loc: {start, end}, content

