function ensure_progress(loc0, loc1) ::
  if loc0.pos == loc1.pos ::
    throw new Error @ `Scanner failed to make progress`

  if loc0.pos > loc1.pos ::
    throw new Error @ `Scanner went backward`


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

export class DispatchScanner ::
  startCompile() ::
    Object.defineProperties @ this, @{}
      regexp: @{} value: []
    this.by_kind = {}
    this.by_op = {}
    return this

  addScanner(scanner) ::
    if scanner.withDispatch ::
      scanner = scanner.withDispatch(this)

    this.by_op[scanner.op] = scanner
    return scanner

  addRegExpScanner(scanner, kind, re_disp) ::
    this.by_kind[kind] = scanner.op
    this.regexp.push @ `(?:${re_disp})`

  finishCompile(ds_body) ::
    if ! ds_body :: ds_body = this.by_op.src
    const rx = new RegExp @ this.regexp.join('|'), 'g'

    return Object.defineProperties @ this, @{}
      rx: @{} value: rx
      ds_body: @{} value: ds_body, writable: true


  cloneWithOps(by_op_override) ::
    const self = Object.create(this)
    self.by_op = Object.assign @ {}, this.by_op, by_op_override
    self.ds_body = self.by_op.src
    self.level = 1 + 0|self.level
    self.description = self.description.replace @
      /\(\d+\)/, `(${self.level})`
    return self


  newline(ctx) ::

  scan(ctx, idx0) ::
    const loc0 = ctx.loc_tip
    const res = this._scan(ctx, idx0)
    ensure_progress @ loc0, ctx.loc_tip
    return res

  _scan(ctx, idx0) ::
    const rx = this.rx
    rx.lastIndex = idx0

    const source = ctx.ln_source
    const match = rx.exec(source)

    if null === match ::
      return this.ds_body.scan(ctx, idx0)

    const idx1 = match.index
    if idx0 !== idx1 ::
      return this.ds_body.scan_fragment @
        ctx, source.slice(idx0, idx1)

    const kind = match.filter(Boolean)[1]
    const op = this.by_kind[kind]
    const op_scanner = this.by_op[op]
    if ! op_scanner ::
      throw new Error @ `No scanner registered for « ${kind} »`

    return op_scanner.scan(ctx, idx1)

  scan_fragment(ctx, content) ::
    throw new Error @ `Dispatch scanner does not support fragments`


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

export class DispatchFirstlineScanner extends DispatchScanner ::
  scan(ctx, idx0) ::
    ctx.scanner = this.ds_body
    return super.scan(ctx, idx0)

  scan_fragment(ctx, content) ::
    throw new Error @ `First line dispatch scanner does not support fragments`


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

export class BaseSourceScanner ::
  constructor(options) ::
    Object.assign(this, options)
    this._compileForInit()

  _compileForInit() ::

  withDispatch(ds) ::
    const self = Object.create @ this, @{}
      dispatch: {value: ds}
    return self

  emit_ast(ctx, content, ast_type) ::
    const start = ctx.loc_tip
    const end = ctx.loc_tip = start.move(content)
    const ast = @{} type: ast_type || this.op, loc: {start, end}, content
    this._ast_extend(ctx, ast)
    ctx.parts.push @ ast
    return ast

  _ast_extend(ctx, ast) ::

  newline(ctx) ::
  scan_fragment(ctx, content) ::
    throw new Error @ `Scanner (${this.description}) does not support fragments`
  scan(ctx, idx0) ::
    throw new Error @ `Scanner (${this.description}) does not support scans`


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

export class SourceCodeScanner extends BaseSourceScanner ::
  scan_fragment(ctx, content) ::
    this.scan_content @ ctx, content

  scan(ctx, idx0) ::
    this.scan_content @ ctx, ctx.ln_source.slice(idx0)

  scan_content(ctx, content) ::
    this.emit_ast @ ctx, content


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

export class NestedCodeScanner extends SourceCodeScanner ::
  constructor(options) ::
    super(options)
    if ! this.char_pairs ::
      throw new Error @ 'Missing required char_pairs mapping'

    const chars = Object.keys(this.char_pairs).join('\\')
    this.rx = new RegExp(`([${chars}])`)

  withOuter(options) ::
    const scanner = options.scanner
    if 'function' !== typeof scanner.scan ::
      throw new Error @ `Expected valid outer scanner`
    delete options.scanner

    const self = Object.create @ this, @{}
      restore_scanner: @{} value: scanner
    Object.assign @ self, options
    return self

  scan_content(ctx, nested_content) ::
    const {stack, char_pairs} = this

    let content = ''
    for const tok of nested_content.split(this.rx) ::
      const p = 1 === tok.length ? char_pairs[tok] : undefined

      if undefined === p ::
        content += tok
        continue

      if true === p ::
        content += tok
        stack.push @ tok
        continue

      const tip = stack.pop()
      if tip !== p ::
        const loc = ctx.loc_tip.move(content)
        throw new SyntaxError @ `Mismatched nesting in ${this.description} (${loc.toString()})`

      if 0 !== stack.length ::
        content += tok
        continue

      this.emit_ast @ ctx, content
      this.emit_ast @ ctx, tok, this.ast_end || 'nested_end'
      ctx.scanner = this.restore_scanner
      return

    // all tokens with non-zero stack
    this.emit_ast @ ctx, content


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

export class BaseRegExpScanner extends BaseSourceScanner ::

  _compileForInit() ::
    const {rx_open, rx_close} = this
    const rx_disp = new RegExp @
      (rx_open ? rx_open.source : '') + rx_close.source

    const rx_resume = new RegExp @
      '^' + rx_close.source

    Object.defineProperties @ this, @{}
      rx_disp: @{} value: rx_disp
      rx_resume: @{} value: rx_resume

  newline(ctx) ::
    throw new SyntaxError @ `Newline in ${this.description} (${ctx.ln.loc.end.toString()})`

  scan(ctx, idx0) ::
    const match = this.rx_disp.exec @ ctx.ln_source.slice(idx0)
    const [content, open, close] = match

    this.emit_ast @ ctx, this.nestTrim(content, close, true)
    return this._post_scan(ctx, close)

  scan_continue(ctx, idx0) ::
    const match = this.rx_resume.exec @ ctx.ln_source.slice(idx0)
    const [content, close] = match

    this.emit_ast @ ctx, this.nestTrim(content, close, true)
    return this._post_scan(ctx, close)

  nestTrim(content, close, isContinue) ::
    const trim = this.nestingTrim
    if undefined !== trim ::
      if trim[close] ::
        return content.slice(0, - close.length)

    return content

  _post_scan(ctx, close) ::
    if ! close :: return

    return this.nestMatch @ close,
      ctx, this.dispatch,
      this

  nestMatch(close, ctx, dispatch, scanner) ::
    const nesting = this.nesting
    if undefined !== nesting ::
      return this._nestWith @
        nesting[close],
        ctx, dispatch, scanner
    return true // pop ctx.scanner

  _nestWith(nested, ctx, dispatch, hostScanner) ::
    if undefined === nested || null === nested ::
      return true // pop ctx.scanner
    if 'function' === typeof nested ::
      return nested @ ctx, dispatch, hostScanner
    else if 'function' === typeof nested.nestedScanner ::
      ctx.scanner = nested.nestedScanner(ctx)
      return
    else return nested


  nestedScanner(ctx) ::
    return this._asNestedScanner @ ctx, 'nest', @{}

  continueScanner(ctx) ::
    return this._asNestedScanner @ ctx, 'cont', @{}
      continueScanner(ctx) :: return this
      scan(ctx, idx0) ::
        this.scan_continue(ctx, idx0)

  _asNestedScanner(ctx, desc, body) ::
    const restore_scanner = ctx.scanner
    const self = @{}
      __proto__: this
      description: `${this.description} (${desc})`
      ln_first: ctx.ln

      _pop_scanner(ctx) ::
        if this.op_pop ::
          this.emit_ast @ ctx, '', this.op_pop
        ctx.scanner = restore_scanner

      scan(ctx, idx0) ::
        if true === super.scan(ctx, idx0) ::
          this._pop_scanner(ctx)

      scan_continue(ctx, idx0) ::
        if true === super.scan_continue(ctx, idx0) ::
          this._pop_scanner(ctx)

    return Object.assign @ self, body


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

export class NestedRegExpScanner extends BaseRegExpScanner ::


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

export class RegExpScanner extends BaseRegExpScanner ::
  withDispatch(ds) ::
    const self = super.withDispatch(ds)
    self.compileForDispatch(ds)
    return self

  compileForDispatch(ds) ::
    const match = this.rx_disp.exec @ this.example
    if this.kind !== match[1] || null == match[2] ::
      throw new Error @ `Invalid scanner regexp and/or example ()`

    ds.addRegExpScanner @ this, this.kind, this.rx_disp.source


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

export class MultiLineScanner extends RegExpScanner ::
  newline(ctx) ::

  _ast_extend(ctx, ast) ::
    const ln = this.ln_first || ctx.ln
    if undefined !== ln.len_inner ::
      ast.block_indent = ln.len_inner
    return ast

  _post_scan(ctx, close, restore_scanner) ::
    if close ::
      return super._post_scan(ctx, close, restore_scanner)

    ctx.scanner = this.continueScanner(ctx)


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

export class DynamicScanner extends MultiLineScanner ::
  scan(ctx, idx0) ::
    const source = ctx.ln_source.slice(idx0)
    const leader_match = this.rx_disp.exec @ source

    const self = this.withLeader(leader_match[2])
    return self.scan_leader(ctx, source, idx0)


  withLeader(leader) ::
    const rx_dyn_open = new RegExp @
      this.rx_leader_open.source.replace @ /leader/g, leader

    const rx_resume = new RegExp @
      '^' + this.rx_leader_close.source.replace @ /leader/g, leader

    return Object.create @ this, @{}
      rx_resume: @{} value: rx_resume
      rx_dyn_open: @{} value: rx_dyn_open


  scan_leader(ctx, source, idx0) ::
    const [content] = this.rx_dyn_open.exec(source)
    this.emit_ast @ ctx, content, this.op_leader
    idx0 += content.length
    return this.scan_continue(ctx, idx0)

