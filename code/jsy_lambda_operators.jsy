const rx_lambda_kind = /^([*>])*/

const lambda_block_tbl = @{}
  '': a => @: pre: `(function (${a}) {`, post: '}).bind(this)'
  '>': a => @: pre: `(async function (${a}) {`, post: '}).bind(this)'
  '>*': a => @: pre: `(async function * (${a}) {`, post: '}).bind(this)'
  '*>': a => @: pre: `(async function * (${a}) {`, post: '}).bind(this)'
  '*': a => @: pre: `(function * (${a}) {`, post: '}).bind(this)'

const lambda_arrow_tbl = @{}
  __proto__: lambda_block_tbl
  '': a => @: pre: `((${a}) =>`, post: ')', implicitCommas: true
  '>': a => @: pre: `(async (${a}) =>`, post: ')', implicitCommas: true


function lambda_resolve(table, args, suffix) ::
  let entry
  const m_prefix = args.match(rx_lambda_kind)
  if ! m_prefix || ! m_prefix[0] ::
    entry = table[suffix || '']

  else if suffix ::
    throw new SyntaxError @ `JSY lambda expression overspecified ("${m_prefix[0]}" and "${suffix}")`

  else ::
    entry = table[ m_prefix[0] ]
    args = args.replace(m_prefix[0], '')

  if undefined === entry ::
    throw new SyntaxError @ `JSY lambda expression unrecognized specifier ("${t}")`

  return entry(args)

export const at_lambda_experimental = @[]
  /* experimental ideas */
  @{} jsy_op: '@|>', pre: '([', post: '].reduce((v,f)=>f(v)))', implicitCommas: true

  @{} jsy_op0: '@\\=>', jsy_op: /@\\(.*?)=>([*>]*)/,
      pre: '(()=>', post: ')', implicitCommas: true,
      opResolve(p) ::
        const [_, args, suffix] = p.content.match(this.jsy_op)
        return lambda_resolve @ lambda_arrow_tbl, args, suffix

  @{} jsy_op0: '@\\::', jsy_op: /@\\(.*?)::/,
      pre: '(()=>{', post: '})',
      opResolve(p) ::
        const [_, args] = p.content.match(this.jsy_op)
        return lambda_resolve @ lambda_block_tbl, args, ''

export default at_lambda_experimental
